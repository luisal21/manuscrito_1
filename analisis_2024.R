# In this script I show analysis of floral traits from Cucurbita species 
# evaluated in this study. I also analyze sugar and amino acid concentration
# between species. Additionally, I evaluate pollen traits.

#### functions I use in the analysis ####
# function to obtain standard error
es <- function(x){
  sd(x) / sqrt(length(x))
}
# function to obtain coefficient of variance
cv <- function(x){
  (sd(x)/mean(x))*100
}

#### package to use ####
library(car)
library(MASS)
library(lme4)
#library(nlme)
#library(fitdistrplus)
library(ggplot2)
library(ggsignif)
library(forcats)
library(dplyr)
library(emmeans)
library(multcomp)
#install.packages("multcompView")
library(multcompView)
library(tidyr)

#### Set up directory in which the databases are located ####
setwd("/home/luis/Documents/3_Doctorado_UNAM/manuscrito_1/data_variables")
#### Cargando base de datos de caracteres florales de flores hembra ####
hembras <- read.csv("flores_hembra.csv", header = T)
head(hembras)
str(hembras)
tapply(hembras$CD, list(hembras$especie, hembras$sitio), length)
tapply(hembras$CD, hembras$sitio, length)

### Subset of Morelia flowers
hembras = subset(hembras, sitio == "morelia")
head(hembras)
str(hembras)
tapply(hembras$CD, hembras$especie, length)


# clustering by plant ID
hem_resu <- hembras %>%
  group_by(año,condición,especie2,especie,id_planta2) %>%
  dplyr::summarize(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
                   TD2 = mean(TD2), TD3 = mean(TD3), NDf = mean(NDf), SD = mean(SD),
                   PL = mean(PL), SL = mean(SL), OL = mean(OL), OD = mean(OD), 
                   VN = mean(vol_nec), n = n())

hem_resu2 <- as.data.frame(hem_resu)
str(hem_resu2)
tapply(hem_resu2$CD, hem_resu2$especie, length)
#write.csv(hem_resu2, file="hem_resu.csv")

#### descriptive statistics of pistillate floral traits ####
# Mean
media = hem_resu2 %>%
  group_by(especie) %>%
  dplyr::summarize(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
                   TD2 = mean(TD2), TD3 = mean(TD3), NDf = mean(NDf), SD = mean(SD),
                   PL = mean(PL), SL = mean(SL), OL = mean(OL), OD = mean(OD), 
                   VN = mean(VN),n = n())
View(media)
#write.csv(media, file = "hembras_mean.csv")
# Standard error
erro = hem_resu2 %>%
  group_by(especie) %>%
  dplyr::summarize(CD = es(CD), TL = es(TL), CL = es(CL), TD1 = es(TD1), 
                   TD2 = es(TD2), TD3 = es(TD3), NDf = es(NDf), SD = es(SD), 
                   PL = es(PL), SL = es(SL), OL = es(OL), OD = es(OD), 
                   VN = es(VN), n = n())
View(erro)
# Coefficient of variation
CV = hem_resu2 %>%
  group_by(especie) %>%
  dplyr::summarize(CD = cv(CD), TL = cv(TL), CL = cv(CL), TD1 = cv(TD1),
                   TD2 = cv(TD2), TD3 = cv(TD3), NDf = cv(NDf), SD = cv(SD), 
                   PL = cv(PL), SL = cv(SL), OL = cv(OL), OD = cv(OD),
                   VN = cv(VN), n = n())
View(CV)

#### Principal component analysis (PCA) of pistillate's floral traits ####
# First 6 lines of the database
head(hem_resu2)
str(hem_resu2)
# plotting variables with pairs
pairs(hem_resu2[6:17])
# Performing the PCA with the "prcomp" function
pca1 <- prcomp(hem_resu2[, 6:17], scale = T)
# information generated by the PCA
summary(pca1)
pca1$rotation[, 1:2]
plot(pca1)
# visualization of PCA
biplot(pca1, scale=0)

# Loading libraries to plot PCAs
library(FactoMineR)
library(factoextra)

# Obtaining information on the eigenvalues of the PCA
get_eigenvalue(pca1)
# percentage of variance explained by each component of the PCA
fviz_eig(pca1, addlabels = T)
# Information obtained from the variables we use for the PCA
var = get_pca_var(pca1); var

# Visualizing variables from PCA
fviz_pca_var(pca1, col.var = "black")
# Quality of the representation of the variables in the factor map
head(var$cos2)

# Loading package "corrplot" to visualize correlations
library(corrplot)
# Correlations between variables (cos2)
corrplot(var$cos2, is.corr = F)
# Visualizing the quality of the representation, which variables are best 
# represented.
fviz_cos2(pca1, choice = "var", axes = 1:2)
fviz_pca_var(pca1, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribution of each variable
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca1, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca1, choice = "var", axes = 2, top = 10)
# Contribution of the variables adding the 2 components
fviz_contrib(pca1, choice = "var", axes = 1:2, top = 10)
# PCA plot of the variables colored by contribution 
fviz_pca_var(pca1, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)


### Graph of individuals (rows)
ind = get_pca_ind(pca1)
# Elements that can be taken out of the ind
ind
# Visualizing the individuals in the PCA plot
fviz_pca_ind(pca1)
# Visualizing the individuals in the PCA as a function of cos2
fviz_pca_ind(pca1, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Visualizing the individuals in the PCA as a function of cos2
fviz_pca_ind(pca1, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Total contribution on PC1 and PC2
fviz_contrib(pca1, choice = "ind", axes = 1:2)


# Clustering by species
hem_resu2 <- hem_resu2 %>%
  mutate(especie2 = fct_relevel(especie2,
                                "CF","CPF", "CAS", "CPP", "CAA", "CM"))
pca_hembras <- fviz_pca_ind(pca1,
             #geom.ind = "point", # show points only (nbut not "text")
             habillage = hem_resu2$especie2, # color by groups
            palette = "Dark2",
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
            #ellipse.level = 0.95,
            legend.title = "Species",
            title = "",
            pointshape = 19,
            pointsize = 1.5,
            label = "none"
)+
  labs(x = "PC 1 (67.8%)", y = "PC 2 (13.3%)")
  #theme(legend.position = "none")

pca_hembras

### PERMANOVA of pistillate flowers
library(vegan)
head(hem_resu2)
str(hem_resu2)
dune5 = hem_resu2[6:17]
# calculating PERMANOVA by species
set.seed(0)
dune.div6 <- adonis2(dune5 ~ especie, data = hem_resu2,
                     permutations = 999, method="euclidean")
dune.div6

# calculando beta dispersión (homogeneidad de varianzas)
bd <- betadisper(dune.dist5, hem_resu2$condición)
anova(bd)
permutest(bd)
plot(bd, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=hem_resu2$especie)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


#### Database of floral traits of staminate flowers of Cucurbita species ####
machos <- read.csv("flores_macho.csv", header = T)
head(machos)
str(machos)
tapply(machos$CD, list(machos$especie, machos$sitio), length)
tapply(machos$CD, machos$sitio, length)

# subset of Morelia flowers
machos = subset(machos, sitio == "morelia")
str(machos)

# Clustering by plant ID
machos2 = machos %>%
  group_by(año, condicion, especie, especie2, id_planta) %>%
  summarise(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
            TD2 = mean(TD2), TD3 = mean(TD3), NDm = mean(NDm), AD = mean(AD),
            StL = mean(StL), AL = mean(AL), VN = mean(vol_nec), n = n())
str(machos2)
tapply(machos2$CD, machos2$especie2, length)
#View(machos2)
#write.csv(machos2, file = "machos2_prom.csv")


#### Descriptive statistics of staminate flowers ####
# Mean
machos3 = machos2 %>%
  group_by(especie) %>%
  summarise(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
            TD2 = mean(TD2), TD3 = mean(TD3), NDm = mean(NDm), AD = mean(AD),
            StL = mean(StL), AL = mean(AL), VN = mean(VN), n = n())
# exporting mean by floral trait
#write.csv(machos3, file = "machos_mean.csv")
View(machos3)


# Standard error
erro_m = machos2 %>%
  group_by(especie) %>%
  summarise(CD = es(CD), TL = es(TL), CL = es(CL), TD1 = es(TD1), 
            TD2 = es(TD2), TD3 = es(TD3), NDm = es(NDm), AD = es(AD), 
            StL = es(StL), AL = es(AL), VN = es(VN), n = n())
View(erro_m)
# Coefficient of variance
cv_m = machos2 %>%
  group_by(especie) %>%
  summarise(CD = cv(CD), TL = cv(TL), CL = cv(CL), TD1 = cv(TD1),
            TD2 = cv(TD2), TD3 = cv(TD3), NDm = cv(NDm), AD = cv(AD), 
            StL = cv(StL), AL = cv(AL), VN = cv(VN), n = n())

#### Principal component analysis (PCA) of staminate floral traits ####
head(machos2)
machos2 = as.data.frame(machos2)
str(machos2)
pairs(machos2[6:15])
pca2 <- prcomp(machos2[, 6:15], scale = T)
summary(pca2)
pca2$rotation[, 1:2]
#write.csv(pca1$rotation[, 1:2], file = "pca_hembras.csv")
plot(pca2)
biplot(pca2, scale=0)

# Obteniendo información sobre los eigenvalues del PCA
get_eigenvalue(pca2)
# porcentaje de varianza explicada por cada componente del PCA
fviz_eig(pca2, addlabels = T)
# Información que se obtiene de las variables que usamos para el PCA
var = get_pca_var(pca2); var

# Visualizando las variables del PCA
fviz_pca_var(pca2, col.var = "black")
# Calidad de la representación de las variables en el mapa de factores
head(var$cos2)
# Correlaciones entre calidades (cos2)
corrplot(var$cos2, is.corr = F)
# Visualizando la calidad de la representación, que variables estan mejor
# representadas. Grafica de barras y mapa de factores
fviz_cos2(pca2, choice = "var", axes = 1:2)
fviz_pca_var(pca2, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución de cada variable
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca2, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca2, choice = "var", axes = 2, top = 10)
# Contribución de las variables sumando los 2 componentes
fviz_contrib(pca2, choice = "var", axes = 1:2, top = 10)
# Gráfica de PCA de las variables coloreando por contribución 
fviz_pca_var(pca2, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

### Gráfica de individuos (filas)
ind = get_pca_ind(pca2)
# Elementos que se pueden sacar de los ind
ind
# Visualizando los individuos en el grafico de PCA
fviz_pca_ind(pca2)
# Visualizando los individuos en el PCA en función de cos2
fviz_pca_ind(pca2, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Visualizando los individuos en el PCA en funcións de cos2
fviz_pca_ind(pca2, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Total contribution on PC1 and PC2
fviz_contrib(pca2, choice = "ind", axes = 1:2)


# Clustering by species

machos2 <- machos2 %>%
  mutate(especie2 = fct_relevel(especie2,
                    "CF","CPF", "CAS", "CPP", "CAA", "CM"))
pca_machos <- 
  fviz_pca_ind(pca2,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = machos2$especie2, # color by groups
             palette = "Dark2",
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
             legend.title = "Species",
             title = "",
             pointshape = 19,
             pointsize = 1.5,
             #label = "none"
)+
  labs(x = "PC 1 (53.2%)", y = "PC 2 (21.9%)")
 #theme(legend.position = "none")


pca_hembras
pca_machos

# code to paste graphs
# loading packages
library(gridExtra)
library(cowplot)
library(ggpubr)
# joining plots
gt <- ggarrange(pca_hembras, pca_machos,
                ncol = 1, nrow = 2, common.legend = TRUE, legend = "right",
                labels="AUTO")
gt
# Exporting plot
ggsave("Figure_1.png", device = "png", width = 172, height = 172,
       units = "mm", dpi = 600, bg = "white")


### PERMANOVA of staminate flowers
head(machos2)
str(machos2)
dune6 = machos2[6:15]
# Calculando distancia euclidiana
set.seed(0)
# calculando PERMANOVA por especie
dune.div7 <- adonis2(dune6 ~ especie, data = machos2,
                     permutations = 999, method="euclidean")
dune.div7

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


#### VOLUMEN DE NECTAR ####
# Volumen de néctar de flores hembra
vol_nec2 = subset(hembras, vol_nec != 0)
vol_nec3 = subset(vol_nec2, vol_nec < 300)
sort(vol_nec3$vol_nec)
boxplot(vol_nec3$vol_nec ~ vol_nec3$especie)
tapply(vol_nec3$vol_nec, vol_nec3$especie, mean)
tapply(vol_nec3$vol_nec, vol_nec3$especie, es)
str(vol_nec3)

# Agrupando el volumen de nectar por individuo
hem_nec <- vol_nec3 %>%
  group_by(año,condición,especie,id_planta2) %>%
  dplyr::summarize(VN = mean(vol_nec), n = n()); hem_nec


# Volumen de néctar de flores macho
machos2 <- subset(machos, vol_nec != 0)
machos3 <- subset(machos2, vol_nec < 150)
str(machos3)
sort(machos3$vol_nec)
# Agrupando volumen de néctar por individuo
mac_nec <- machos3 %>%
  group_by(año,condicion,especie,id_planta2) %>%
  dplyr::summarize(VN = mean(vol_nec), n = n()); mac_nec
# obteniendo media, error standard y numero de individuos por condicion
tapply(mac_nec$VN, mac_nec$condicion, mean)
tapply(mac_nec$VN, mac_nec$condicion, es)
tapply(mac_nec$VN, mac_nec$condicion, length)
boxplot(mac_nec$VN ~ mac_nec$especie)

### Uniendo base de hembras y machos
#str(hem_nec)
#str(mac_nec)
#write.csv(hem_nec, file = "nectar_female.csv")
#write.csv(mac_nec, file = "nectar_male.csv")

# Cargando base conjunta de volumen de nectar 
volumen = read.csv("nectar_volume.csv", header = T)
head(volumen)
str(volumen)
# Descriptive statistics
tapply(volumen$VN, list(volumen$especie, volumen$sexo), mean)
tapply(volumen$VN, list(volumen$especie, volumen$sexo), es)
tapply(volumen$VN, list(volumen$especie, volumen$sexo), length)

hist(volumen$VN)
shapiro.test(volumen$VN)
shapiro.test(log(volumen$VN))
hist(log(volumen$VN))

# GLM of nectar volume by species and floral sex
volu = glm(log(VN) ~ especie*sexo, data = volumen, family = gaussian)
summary(volu) #, dispersion=1
Anova(volu)
shapiro.test(residuals(volu))
plot(residuals(volu))
volu_compa <- emmeans(volu, 
                      specs = pairwise ~ especie | sexo, 
                      type = "response")
volu_compa
volu_compa.m<-volu_compa$emmean 
volu_compa.m
model_means_cld_volu <- cld(object = volu_compa.m,
                            adjust = "sidak",
                            Letter = letters, 
                            alpha = 0.05)
model_means_cld_volu


# GLM with Gamma distribution
volu2 = glm(VN ~ especie*sexo, data = volumen, family = Gamma)
summary(volu2) #, dispersion=1
Anova(volu2)
shapiro.test(residuals(volu2))
plot(residuals(volu2))


#### PCA con los caracteres del néctar ####
# Caracteres del nectar floral (volumen, azucares y aminoacidos) de flores
# hembra y macho
nectar = read.csv("traits_nectar.csv", header = T)
head(nectar)
str(nectar)
tapply(nectar$fructose, nectar$sexo, length)
# Separando machos y hembras
# flores hembra
nectar_h = subset(nectar, sexo =="h")
str(nectar_h)
# flores macho
nectar_m = subset(nectar, sexo =="m")
str(nectar_m)

# PCA de caracteres del néctar de flores hembra
# visualizando todas las combinaciones entre las variables
pairs(nectar_h[8:29], lower.panel = NULL)
# Calculando el PCA para flores hembra
pca4 = prcomp(nectar_h[8:29], scale = T)
summary(pca4)
# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca4)
# calculando la varianza explicada por cada componente
fviz_eig(pca4, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca4); var
# Visualización de las variables
fviz_pca_var(pca4, col.var = "black")

# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca4, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca4, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca4, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca4, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca4, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca4, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

# Solo caracteres del nectar
fviz_pca_var(pca4, col.var = factor(c("nectar","nectar","nectar",
                                      "nectar","nectar","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid")), 
             palette = c("#0073C2FF", "#EFC000FF"),
             legend.title = "Cluster")

### Graph of individuals (rows)
ind = get_pca_ind(pca4)
ind

fviz_pca_ind(pca4)
# Visualizando los individuos por cos2
fviz_pca_ind(pca4, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca4, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca4, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = nectar_h$condicion, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2
)+
labs(x = "PC 1 (54%)", y = "PC 2 (12.7%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = nectar_h$condicion, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2,
             label = "none"
)+
  labs(x = "PC 1 (54%)", y = "PC 2 (12.7%)")


# Agrupado por especie
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = nectar_h$spp, # color by groups
             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
                         "#E7B850"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "confidence",
             legend.title = "Groups"
)

### agrupado por condición + las variables
fviz_pca_biplot(pca4,
                col.ind = nectar_h$condicion, palette = "jco",
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Condition"
)

library(MVN)
# Flores hembra
mvn(nectar_h[8:29], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")
mvn(nectar_h[8:12], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# Flores macho
mvn(nectar_m[8:29], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# PERMANOVA del nectar de flores hembra
str(nectar_h)
nectar_h[8:29]
dune8 = nectar_h[8:29]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div8 <- adonis2(dune8 ~ condicion, data = nectar_h,
                     permutations = 999, method="euclidean")
dune.div8

# calculando PERMANOVA por especie
dune.div8 <- adonis2(dune8 ~ spp, data = nectar_h,
                     permutations = 999, method="euclidean")
dune.div8

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse

# MANOVA del nectar
# MANOVA test
mod1<-manova(cbind(fructose, glucose, sucrose) ~ condicion, 
             data = nectar_h)
summary(mod1) #Diferencias significativas



### FLORES MACHO
nectar_m = subset(nectar, sexo =="m")
str(nectar_m)

# PCA de caracteres del néctar de flores hembra
# visualizando todas las combinaciones entre las variables
pairs(nectar_m[8:29], lower.panel = NULL)
# Calculando el PCA para flores machos
pca5 = prcomp(nectar_m[8:29], scale = T)
summary(pca5)
# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca5)
# calculando la varianza explicada por cada componente
fviz_eig(pca5, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca5); var
# Visualización de las variables
fviz_pca_var(pca5, col.var = "black")

# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca5, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca5, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca5, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca5, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca5, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca5, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

# Solo caracteres del nectar
fviz_pca_var(pca5, col.var = factor(c("nectar","nectar","nectar",
                                      "nectar","nectar","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid",
                                      "aminoacid","aminoacid","aminoacid")), 
             palette = c("#0073C2FF", "#EFC000FF"),
             legend.title = "Cluster")

### Graph of individuals (rows)
ind = get_pca_ind(pca5)
ind

fviz_pca_ind(pca5)
# Visualizando los individuos por cos2
fviz_pca_ind(pca5, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca5, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca5, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca5,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = nectar_m$condicion, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2
)+
  labs(x = "PC 1 (53.4%)", y = "PC 2 (11.6%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca5,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = nectar_m$condicion, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2,
             label = "none"
)+
  labs(x = "PC 1 (53.4%)", y = "PC 2 (11.6%)")

# Agrupado por especie
fviz_pca_ind(pca5,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = nectar_m$spp, # color by groups
             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
                         "#E7B850", "#FF8400"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "confidence",
             legend.title = "Groups"
)

### agrupado por condición + las variables
fviz_pca_biplot(pca5,
                col.ind = nectar_m$condicion, palette = "jco",
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Condition"
)

# PERMANOVA del nectar de floress macho
str(nectar_m)
nectar_m[8:29]
dune9 = nectar_m[8:29]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div9 <- adonis2(dune9 ~ condicion, data = nectar_m,
                     permutations = 999, method="euclidean")
dune.div9

# calculando PERMANOVA por especie
dune.div9 <- adonis2(dune9 ~ spp, data = nectar_m,
                     permutations = 999, method="euclidean")
dune.div9

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


##### PCA DE RASGOS DEL POLEN ####
setwd("/home/luis/Documents/3_Doctorado_UNAM/a-proyecto/analisis_florales_tesis_2022/rasgos_polen")
# cargando base depurada de todos los rasgos de polen
pollen = read.csv("rasgos_pollen2.csv", header = T)
head(pollen)
str(pollen)

tapply(pollen$produ, pollen$spp, mean)
tapply(pollen$tam, pollen$spp, mean)
tapply(pollen$conc.prot, pollen$spp, mean)
tapply(pollen$conc_lip, pollen$spp, mean)
tapply(pollen$pl, pollen$spp, mean)

# PCA de caracteres del nectar
head(pollen)
str(pollen)
pairs(pollen[6:10])
pca6 <- prcomp(pollen[, 6:10], scale = T)
summary(pca6)
pca6$rotation[, 1:2]
plot(pca6)
#write.csv(pca1$rotation[, 1:2], file = "pca_hembras.csv")
biplot(pca6, scale=0)

# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca6)
# calculando la varianza explicada por cada componente
fviz_eig(pca6, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca6); var
# Visualización de las variables
fviz_pca_var(pca6, col.var = "black")

# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca6, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca6, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca6, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca6, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca6, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca6, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

### Graph of individuals (rows)
ind = get_pca_ind(pca6)
ind

fviz_pca_ind(pca6)
# Visualizando los individuos por cos2
fviz_pca_ind(pca6, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca6, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca6, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca6,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = pollen$condicion, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2
)+
 labs(x = "PC 1 (36.1%)", y = "PC 2 (31.4%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca6,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = pollen$condicion, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2,
             label = "none"
)+
  labs(x = "PC 1 (36.1%)", y = "PC 2 (31.4%)")

# Agrupado por especie
fviz_pca_ind(pca6,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = pollen$spp, # color by groups
             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
                         "#E7B850", "#FF8400"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "confidence",
             legend.title = "Groups"
)

### agrupado por condición + las variables
fviz_pca_biplot(pca6,
                col.ind = pollen$condicion, palette = "jco",
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Condition"
)

# PERMANOVA del polen
str(pollen)
pollen[6:10]
dune10 = pollen[6:10]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div10 <- adonis2(dune10 ~ condicion, data = pollen,
                     permutations = 999, method="euclidean")
dune.div10

# calculando PERMANOVA por especie
dune.div11 <- adonis2(dune10 ~ spp, data = pollen,
                     permutations = 999, method="euclidean")
dune.div11

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse

# Cargando paquete para normalidad de multivarianza
library(mvnormtest)
data("EuStockMarkets")
View(EuStockMarkets)
C <- t(EuStockMarkets[15:29,1:4])
mshapiro.test(C)
# Transponiendo tabla
C = t(pollen[6:10])
# Calculando normalidad de multivarianza
mshapiro.test(C) # no es normal

# Calculando normalidad de cada grupo por variable dependiente
normal<-function(vec){
  shapiro.test(vec)$p
}
aggregate(pollen[,6:10],list(pollen$condicion), normal)
# Calculando normalidad multivariada
library(MVN)
mvn(pollen[, c(6, 7, 8, 9, 10)], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# MANOVA test
mod1<-manova(cbind(produ, tam, conc.prot, conc_lip, pl) ~ condicion, 
             data = pollen)
summary(mod1) #Diferencias significativas




#### CALCULANDO SEÑAL FILOGENÉTICA ####
# Cargando base de datos de todos los caracteres de flores hembra (promedios)
traits_hem = read.csv("hembras_mean.csv", header = T, row.names = 1) #, 
head(traits_hem)
str(traits_hem)
traits_hem[2:35]

#### Calculando la señal filogenetica con la función multiPhylosignal del
# paquete "picante"
library(picante)
head(traits_hem)
arbol <- read.nexus("tree7.nex")
class(arbol)
arbol
names(arbol)
arbol$tip.label

# calculando la K de Blomberg. Este valor mide la señal filogenetica o la 
# tendencia de especies relacioanadas a parecerse unas con otras
traits_h <- (traits_hem[2:35])
str(traits_h)
multiPhylosignal(traits_h, arbol)
#multiPhylosignal(traits_h, multi2di(arbol))
# Guardando tabla
write.csv(multiPhylosignal(traits_h, arbol),
          file = "K_blombergs.csv")

#### Calculando señal filogenética con la lambda de Pagel con el ####
# paquete "phytools"
# Load necessary libraries
library(phytools)
library(dplyr)
library(future.apply)  # For cross-platform parallelization

# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores hembra
traits_hem = read.csv("hembras_mean.csv", header = T)
str(traits_hem)
traits_h <- (traits_hem[3:36])
str(traits_h)

# Function to calculate Pagel's lambda and p-value for each trait
calculate_lambda <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_hem$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
   # group_by(species) %>%
    #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  lambda_result <- phylosig(tree, trait_vector, method = "lambda", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(lambda = lambda_result$lambda, p_value = lambda_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results <- future_sapply(traits_hem[, 3:36], calculate_lambda, tree = arbol)


# Convert the result to a data frame
trait_results_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_df$trait <- colnames(traits_hem)[3:36]  # Add trait names as a column

# View the result
print(trait_results_df)

# Optionally, save the results to a file
write.csv(trait_results_df, "trait_pagels_lambda_results_hembras.csv",
          row.names = FALSE)

# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores macho
traits_mac = read.csv("machos_mean.csv", header = T)
str(traits_mac)

traits_m <- (traits_mac[3:39])
str(traits_m)

# Function to calculate Pagel's lambda and p-value for each trait
calculate_lambda <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_mac$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  lambda_result <- phylosig(tree, trait_vector, method = "lambda", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(lambda = lambda_result$lambda, p_value = lambda_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results <- future_sapply(traits_mac[, 3:39], calculate_lambda, tree = arbol)


# Convert the result to a data frame
trait_results_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_df$trait <- colnames(traits_mac)[3:39]  # Add trait names as a column

# View the result
print(trait_results_df)

# Optionally, save the results to a file
write.csv(trait_results_df, "trait_pagels_lambda_results_machos.csv",
          row.names = FALSE)






#### Calculando señal filogenética con la K de Blomberg con el paquete ####
# "phytools"
# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores hembra
traits_hem = read.csv("hembras_mean.csv", header = T)
str(traits_hem)
traits_h <- (traits_hem[3:36])
str(traits_h)

# Function to calculate Blomberg's K and p-value for each trait
calculate_ka <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_hem$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  ka_result <- phylosig(tree, trait_vector, method = "K", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(ka = ka_result$K, p_value = ka_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results_ka <- future_sapply(traits_hem[, 3:36], calculate_ka, tree = arbol)


# Convert the result to a data frame
trait_results_ka_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_ka_df$trait <- colnames(traits_hem)[3:36]  # Add trait names as a column

# View the result
print(trait_results_ka_df)

# K de Blomberg
write.csv(trait_results_ka_df, "trait_blomberg_K_results_hembras.csv",
          row.names = FALSE)


# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores MACHO para calcular la K de Blomberg
traits_mac = read.csv("machos_mean.csv", header = T)
str(traits_mac)

traits_m <- (traits_mac[3:39])
str(traits_m)

# Function to calculate Blomberg's K and p-value for each trait
calculate_ka <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_mac$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  ka_result <- phylosig(tree, trait_vector, method = "K", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(ka = ka_result$K, p_value = ka_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results_ka <- future_sapply(traits_mac[, 3:39], calculate_ka, tree = arbol)


# Convert the result to a data frame
trait_results_ka_df <- as.data.frame(t(trait_results_ka))  # Transpose to get traits in rows
trait_results_ka_df$trait <- colnames(traits_mac)[3:39]  # Add trait names as a column

# View the result
print(trait_results_ka_df)

# K de Blomberg
write.csv(trait_results_ka_df, "trait_blomberg_K_results_machos.csv",
          row.names = FALSE)




#### Calculando señal filogenetica por separado para cada rasgo ####
# cargando base de datos
traits_hem = read.csv("hembras_mean.csv", header = T, row.names = 1) #, 
head(traits_hem)
str(traits_hem)
arbol$tip.label # cas, cm, caa, cpf, cpp, cf
# Poniendo el nombre de cada especie
homeRange <- setNames(traits_hem$TL,
                    rownames(traits_hem))
# Calculando señal filogenétiNDf# Calculando señal filogenética
#hrangeLambda = 
kresult = phylosig(arbol, homeRange, method = "K", test = TRUE)
kresult$K
kresult$P

hrangeLambda

# Renombrando 
arbol$tip.label

relabel.tips <- c("Cucurbita argyrosperma subsp. sororia",
                  "Cucurbita moschata*",
                  "Cucurbita argyrosperma subsp. argyrosperma*",
                  "Cucurbita pepo subsp. fraterna",
                  "Cucurbita pepo subsp. pepo*",
                  "Cucurbita foetidissima")
# renombrar terminales
#arbol$tip.label <- mixedFontLabel(relabel.tips, italic = 1)
arbol$tip.label <- relabel.tips
plotTree(arbol)

library(ape)
genus <- c("Cucurbita", "Cucurbita", "Cucurbita", "Cucurbita", "Cucurbita",
           "Cucurbita")
species <- c("argyrosperma subsp. sororia", "moschata*", 
             "argyrosperma subsp. argyrosperma*", "pepo subsp. fraterna",
             "pepo subsp. pepo*", "foetidissima")

arbol$tip.label <- mixedFontLabel(genus, species, italic = 1:2)
plot(arbol)



layout(matrix(c(1, 2), 2))
plot(tr)


plot(c(0, 2), c(0, 2))
text(1, 1, bquote(
  paste(
    italic("Italic Text:"),
    " Some words with new lines. ",
    italic("More italic text:"),
    "Yet more words divided by new lines. ",
    italic("Italics again:"),
    "And more text with new lines.",
    sep = ""
  )
)
)


##### PCA de aminoacidos de flores hembra #####
amino = read.csv("concentraciones_aminoacidos.csv", header = TRUE)
str(amino)
head(amino)
tapply(amino$Asp, list(amino$condición,amino$sexo_flor), length)
tapply(amino$Asp, list(amino$condición, amino$sexo_flor), mean)
# concentración de aminoacidos en flores hembra
amino_hem = subset(amino, sexo_flor == "H")
str(amino_hem)
# analisis multivariado de normalidad
mvn(amino_hem[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")

# concentración de aminoacidos en flores hembra
amino_mac = subset(amino, sexo_flor == "M")
str(amino_mac)
# analisis multivariado de normalidad
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")

# PCA de caracteres del néctar de flores hembra
# visualizando todas las combinaciones entre las variables
pairs(amino_hem[8:24], lower.panel = NULL)
# Calculando el PCA para flores hembra
pca4 = prcomp(amino_hem[8:24], scale = T)
summary(pca4)
# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca4)
# calculando la varianza explicada por cada componente
fviz_eig(pca4, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca4); var
# Visualización de las variables
fviz_pca_var(pca4, col.var = "black")

# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca4, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca4, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca4, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca4, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca4, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca4, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

### Graph of individuals (rows)
ind = get_pca_ind(pca4)
ind

fviz_pca_ind(pca4)
# Visualizando los individuos por cos2
fviz_pca_ind(pca4, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca4, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca4, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino_hem$condición, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2
)+
 labs(x = "PC 1 (63.5%)", y = "PC 2 (11.8%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino_hem$condición, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2,
             label = "none"
)+
  labs(x = "PC 1 (63.5%)", y = "PC 2 (11.8%)")


# Agrupado por especie
#fviz_pca_ind(pca4,
#             geom.ind = "point", # show points only (nbut not "text")
#             col.ind = nectar_h$spp, # color by groups
#             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
#                         "#E7B850"),
#             addEllipses = TRUE, # Concentration ellipses
#             #ellipse.type = "confidence",
#             legend.title = "Groups"
#)

### agrupado por condición + las variables
#fviz_pca_biplot(pca4,
#                col.ind = nectar_h$condicion, palette = "jco",
#                addEllipses = TRUE, label = "var",
#                col.var = "black", repel = TRUE,
#                legend.title = "Condition"
#)

library(MVN)
# Flores hembra
mvn(amino_hem[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")



# Flores macho
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# PERMANOVA de aminoacidos de flores hembra
str(amino_hem)
amino_hem[8:24]
dune8 = amino_hem[8:24]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div8 <- adonis2(dune8 ~ condición, data = amino_hem,
                     permutations = 999, method="euclidean")
dune.div8

# calculando PERMANOVA por especie
dune.div8 <- adonis2(dune8 ~ spp, data = nectar_h,
                     permutations = 999, method="euclidean")
dune.div8

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse

#### PCA DE AMINOACIDOS DE FLORES MACHO ####
# concentración de aminoacidos en flores MACHO
amino_mac = subset(amino, sexo_flor == "M")
str(amino_mac)
# analisis multivariado de normalidad
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")

# PCA de caracteres del néctar de flores hembra
# visualizando todas las combinaciones entre las variables
pairs(amino_mac[8:24], lower.panel = NULL)
# Calculando el PCA para flores hembra
pca5 = prcomp(amino_mac[8:24], scale = T)
summary(pca5)
# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca5)
# calculando la varianza explicada por cada componente
fviz_eig(pca5, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca5); var
# Visualización de las variables
fviz_pca_var(pca5, col.var = "black")

# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca5, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca5, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca5, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca5, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca5, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca5, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)


### Graph of individuals (rows)
ind = get_pca_ind(pca5)
ind

fviz_pca_ind(pca5)
# Visualizando los individuos por cos2
fviz_pca_ind(pca5, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca5, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca5, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca5,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino_mac$condición, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2
)+
 labs(x = "PC 1 (61.7%)", y = "PC 2 (12.3%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca5,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino_mac$condición, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2,
             label = "none"
)+
  labs(x = "PC 1 (61.7%)", y = "PC 2 (12.3%)")


# Agrupado por especie
#fviz_pca_ind(pca4,
#             geom.ind = "point", # show points only (nbut not "text")
#             col.ind = nectar_h$spp, # color by groups
#             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
#                         "#E7B850"),
#             addEllipses = TRUE, # Concentration ellipses
#             #ellipse.type = "confidence",
#             legend.title = "Groups"
#)

### agrupado por condición + las variables
#fviz_pca_biplot(pca4,
#                col.ind = nectar_h$condicion, palette = "jco",
#                addEllipses = TRUE, label = "var",
#                col.var = "black", repel = TRUE,
#                legend.title = "Condition"
#)

library(MVN)
# Flores macho
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# PERMANOVA de aminoacidos de flores hembra
str(amino_mac)
amino_mac[8:24]
dune9 = amino_mac[8:24]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div9 <- adonis2(dune9 ~ condición, data = amino_mac,
                     permutations = 999, method="euclidean")
dune.div9

# calculando PERMANOVA por especie
dune.div8 <- adonis2(dune8 ~ spp, data = nectar_h,
                     permutations = 999, method="euclidean")
dune.div8

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse





#### PRODUCCIÓN DE POLEN DE LAS DIFERENTES ESPECIES DE CUCURBITA ####
contador = read.csv("produccion_polen.csv", header = T)
head(contador)
str(contador)
tapply(contador$polen_total, contador$id_planta, length)

#contador$anoplant <- paste(contador$año, contador$id_planta)

# Agrupando por individuo
conta = contador %>%
  group_by(año, condicion, spp, id_planta) %>%
  dplyr::summarize(total_mean = mean(polen_total), 
                   es_total = es(polen_total),
                   n = n())
conta
# Estadística descriptiva de la producción de polen
tapply(conta$total_mean, conta$spp, mean)
tapply(conta$total_mean, conta$spp, es)
tapply(conta$total_mean, conta$spp, length)
#write.csv(conta, file = "produ.csv")

# promedios por especie
conta2 = conta %>%
  group_by(spp) %>%
  dplyr::summarize(total_mean2 = mean(total_mean),
                   es_total2 = es(total_mean), n = n())

conta2

# boxplot por especie
boxplot(conta$total_mean ~ conta$spp)

# histograma y prueba de normalidad
hist(conta$total_mean)
shapiro.test(conta$total_mean) # no normal
shapiro.test(sqrt(conta$total_mean))
shapiro.test(log(conta$total_mean))

# Modelo GLM de producción entre condición
pro2 = glm(total_mean ~ spp, data = conta, family = gaussian(link = "identity"))
summary(pro2)
Anova(pro2)
shapiro.test(residuals(pro2))

# Estimated marginal means 
conta_compa <- emmeans(pro2, 
                       specs = pairwise ~ spp, 
                       type = "response")
conta_compa
conta_compa.m<-conta_compa$emmean 
conta_compa.m
model_means_cld_conta <- cld(object = conta_compa.m,
                             adjust = "sidak",
                             Letter = letters, 
                             alpha = 0.05)
model_means_cld_conta

# Cargando nueva base con la columna de tamaños por individuo
conta3 = read.csv("produ_tam.csv", header = T)
head(conta3)
str(conta3)

# Estadística descriptiva del tamaño del polen
tapply(conta3$tam, conta3$spp, mean)
tapply(conta3$tam, conta3$spp, es)
tapply(conta3$tam, conta3$spp, length)
# grafico de boxplot del tamaño
boxplot(conta3$tam ~ conta3$spp)

# Histograma y shapiro test
hist(conta3$tam)
shapiro.test(conta3$tam) #no normal
shapiro.test(log(conta3$tam))
shapiro.test(sqrt(conta3$tam))

# normalizando datos del tamaño del polen con el paquete bestNormalize
b1 <- bestNormalize::boxcox(conta3$tam)
str(b1)
shapiro.test(b1$x.t)

arcsinh_obj <-arcsinh_x(conta3$tam)
shapiro.test(arcsinh_obj$x.t)

(BNobject <- bestNormalize(conta3$tam))
# orderNorm Transformation
(orderNorm_obj <- orderNorm(conta3$tam))
str(orderNorm_obj)
shapiro.test(orderNorm_obj$x.t)

# Análisis de varianza de la producción de polen
#conta1 = aov(log(total_mean) ~ spp, data = conta3)
#summary(conta1)


# GLM del tamaño del polen
conta2 = glm(tam ~ condicion, data = conta3, family = gaussian)
summary(conta2)
Anova(conta2)

# análisis estadístico del tamaño del polen con una prueba de kruskal-wallis
kruskal.test(tam ~ spp, data = conta3)

# comparaciones múltiples
pairwise.wilcox.test(conta3$tam, conta3$spp,
                     p.adjust.method = "holm")

# Gráfica de la producción de polen
## function to return median and labels
#n_fun <- function(x){
#  return(data.frame(y = median(x) - 10000, 
#                    label = paste0("n = ",length(x))))
#}
head(conta)
# Gráfica de boxplot de la producción de polen
produ <- ggplot(conta, aes(x = spp, y = total_mean, fill = condicion)) +
  geom_boxplot() +
  ## use either geom_point() or geom_jitter()
  geom_point(size = 2, alpha = .3, #aes(color = especie)
             position = position_jitter(seed = 1, width = .1))+
  #stat_summary(geom = "text", fun.data = n_fun)+
  labs(x = "Especies", y = "Producción de polen")+
  scale_x_discrete(labels=c("1CF" = "CF", "2CPF" = "CPF",
                            "3CPP" = "CPP", "4CAS" = "CAS", "5CAA" = "CAA",
                            "6CM" = "CM"))+
  theme_bw()+
  theme(axis.text = element_text(face = "bold"))+
  scale_color_discrete(name="Species",
                       labels = c("CF", "CPF", "CPP", "CAS", "CAA", "CM"))+
  #annotate("text", x=1, y=2000, label= "n = 26", size = 4)+
  #annotate("text", x=2, y=2000, label= "n = 6", size = 4)+
  #annotate("text", x=3, y=2000, label= "n = 28", size = 4)+
  #annotate("text", x=4, y=2000, label= "n = 39", size = 4)+
  #annotate("text", x=5, y=2000, label= "n = 32", size = 4)+
  #annotate("text", x=6, y=2000, label= "n = 31", size = 4)+
  annotate("text", x=1, y=34000, label= "b", size = 5)+
  annotate("text", x=2, y=19000, label= "d", size = 5)+
  annotate("text", x=3, y=21000, label= "d", size = 5)+
  annotate("text", x=4, y=29000, label= "c", size = 5)+
  annotate("text", x=5, y=37000, label= "bc", size = 5)+
  annotate("text", x=6, y=52000, label= "a", size = 5)+
  annotate("text", x=1, y=50000, label= "", size = 5)
theme(legend.position = "none")+
  scale_fill_manual(values = c("#DE7862FF", "#58A449FF"))
produ

#### TAMAÑO DE POLEN DE LAS DIFENTES ESPECIES ####
polen = read.csv("tamaño_polen.csv", header = TRUE)
head(polen)
str(polen)
tapply(polen$micras, polen$especie, mean)
tapply(polen$micras, polen$especie, sd)
tapply(polen$micras, polen$especie, es)
tapply(polen$micras, polen$especie, length)
boxplot(polen$micras ~ polen$especie)

# Histograma del tamaño de polen 
hist(polen$micras)
shapiro.test(polen$micras)
# Análisis de varianza del tamaño de polen entre especies
mod1_polen = aov(polen$micras ~ polen$especie)
summary(mod1_polen)

# comparaciones multiples
compa1 = TukeyHSD(mod1_polen)
compa1
Cld = multcompLetters4(mod1_polen, compa1)
Cld
#
#em1 = emmeans(mod1_polen, specs = pairwise ~ especie)
#em1$emmeans
#em1$contrasts
#write.csv(em1$contrasts, file = "emmeans_polen_tamaño.csv")

# Gráfica del tamaño del polen entre especies
## function to return median and labels
#n_fun <- function(x){
#  return(data.frame(y = median(x) - 22, 
#                    label = paste0("n = ",length(x))))
#}
# Plot
size <- ggplot(conta3, aes(x = spp, y = tam, fill = condicion)) +
  geom_boxplot() +
  ## use either geom_point() or geom_jitter()
  geom_point(size = 2, alpha = .3, #
             position = position_jitter(seed = 1, width = .1))+
  #stat_summary(geom = "text", fun.data = n_fun)+
  #coord_flip()+
  labs(x = "Especies", y = "Tamaño del polen (μm)")+
  scale_x_discrete(labels=c("1CF" = "CF", "2CPF" = "CPF",
                            "3CPP" = "CPP", "4CAS" = "CAS", "5CAA" = "CAA",
                            "6CM" = "CM"))+
  theme_bw()+
  theme(axis.text = element_text(face = "bold"))+
  scale_color_discrete(name="Species",
                       labels = c("CF", "CPF", "CPP", "CAS", "CAA", "CM"))+
  #annotate("text", x=1, y=115, label= "n = 100", size = 4)+
  #annotate("text", x=2, y=115, label= "n = 100", size = 4)+
  #annotate("text", x=3, y=115, label= "n = 100", size = 4)+
  #annotate("text", x=4, y=115, label= "n = 100", size = 4)+
  #annotate("text", x=5, y=115, label= "n = 100", size = 4)+
  #annotate("text", x=6, y=115, label= "n = 100", size = 4)+
  annotate("text", x=1, y=155.5, label= "a", size = 5)+
  annotate("text", x=2, y=142.5, label= "c", size = 5)+
  annotate("text", x=3, y=145, label= "bc", size = 5)+
  annotate("text", x=4, y=147.5, label= "b", size = 5)+
  annotate("text", x=5, y=145, label= "bc", size = 5)+
  annotate("text", x=6, y=146, label= "bc", size = 5)+
  scale_fill_manual(values = c("#DE7862FF", "#58A449FF"))+
  theme(legend.position = "none")
size  
#labels = c("Cucurbita foetidissima (CF)",
#           "Cucurbita pepo subsp. fraterna (CPF)",
#           "Cucurbita pepo subsp. pepo (CPP)",
#           "Cucurbita argyrosperma subsp. sororia (CAS)",
#           "Cucurbita argyrosperma subsp. argyrosperma (CAA)",
#           "Cucurbita moschata (CM)"),
#guide = guide_legend(nrow = 5, 
#                     label.theme = element_text(face = "italic")))

#### CONCENTRACIÓN DE PROTEINAS ####
proteinas = read.csv("concen_protein.csv", header = T)
head(proteinas)
str(proteinas)
tapply(proteinas$prot, proteinas$Especie, length)
#proteinas$anoplant  <- paste(proteinas$año, proteinas$PlantID)

# Agrupando por individuos
conce_prot = proteinas %>%
  group_by(año, Especie, PlantID, Estatus) %>%
  dplyr::summarize(total_conc = mean(prot), es_total = es(prot), n = n())
#write.csv(conce_prot, file ="conce_prot.csv")

tapply(conce_prot$total_conc, conce_prot$Especie, mean)
tapply(conce_prot$total_conc, conce_prot$Especie, es)
tapply(conce_prot$total_conc, conce_prot$Especie, length)

tapply(conce_lipi$total_conc, conce_lipi$Estatus, mean)
tapply(conce_lipi$total_conc, conce_lipi$Estatus, es)
tapply(conce_lipi$total_conc, conce_lipi$Estatus, length)

boxplot(conce_prot$total_conc ~ conce_prot$Especie)
boxplot(conce_prot$total_conc ~ conce_prot$Estatus)
shapiro.test(conce_prot$total_conc)
hist(conce_prot$total_conc)

# GLM de proteinas modelo bueno
modpro = glm(total_conc ~ Especie, data = conce_prot, family = gaussian)
summary(modpro)
Anova(modpro)
shapiro.test(residuals(modpro))


modpro1 = aov(total_conc ~ Estatus, data = conce_prot)
summary(modpro1)

#mod_prot = glm(prot ~ Especie, data = proteinas, family = "Gamma")
#summary(mod_prot)
#Anova(mod_prot)
# comparaciones multiples
#em_prot = emmeans(modpro1, specs = pairwise ~ Especie)
#em_prot$emmeans
#em_prot$contrasts

#mod_prot2 = glmer(prot ~ Especie + (1|PlantID), nAGQ = 0, data = proteinas,
#                  family = Gamma)
#summary(mod_prot2)
#Anova(mod_prot2)
# comparaciones multiples

# Plot
prot <- ggplot(conce_prot, aes(x = Especie, y = total_conc, fill = Estatus)) +
  geom_boxplot() +
  ## use either geom_point() or geom_jitter()
  geom_point(size = 2, alpha = .5, #
             position = position_jitter(seed = 1, width = .1))+
  #stat_summary(geom = "text", fun.data = n_fun)+
  #coord_flip()+
  labs(x = "Especies", y = "Concentración de proteínas (µg/mg)")+
  scale_x_discrete(labels=c("1CF" = "CF", "2CPF" = "CPF",
                            "3CPP" = "CPP", "4CAS" = "CAS", "5CAA" = "CAA",
                            "6CM" = "CM"))+
  theme_bw()+
  theme(axis.text = element_text(face = "bold"))+
  scale_color_discrete(name="Species",
                       labels = c("CF", "CPF", "CPP", "CAS", "CAA", "CM"))+
  #annotate("text", x=1, y=60, label= "n = 26", size = 4)+
  #annotate("text", x=2, y=60, label= "n = 21", size = 4)+
  #annotate("text", x=3, y=60, label= "n = 16", size = 4)+
  #annotate("text", x=4, y=60, label= "n = 33", size = 4)+
  #annotate("text", x=5, y=60, label= "n = 33", size = 4)+
  #annotate("text", x=6, y=60, label= "n = 43", size = 4)+
  theme(legend.position = "none")+
  scale_fill_manual(values = c("#DE7862FF", "#58A449FF"))
prot

#### CONCENTRACIÓN DE LIPIDOS EN EL POLEN ####
lipi = read.csv("lipidos.csv", header = T)
head(lipi)
str(lipi)

# Agrupando por individuos
#lipi$anoplant = paste(lipi$año, lipi$PlantID)

# Agrupando por especie
conce_lipi = lipi %>%
  group_by(año, Especie, PlantID, Estatus) %>%
  dplyr::summarize(total_conc = mean(lipidos), es_total = es(lipidos), n = n())
conce_lipi
#write.csv(conce_lipi, file = "conce_lipi.csv")

# EStadistica descriptiva
tapply(conce_lipi$total_conc, conce_lipi$Especie, mean)
tapply(conce_lipi$total_conc, conce_lipi$Especie, es)
tapply(conce_lipi$total_conc, conce_lipi$Especie, length)


boxplot(conce_lipi$total_conc ~ conce_lipi$Especie)
shapiro.test(conce_lipi$total_conc)
hist(conce_lipi$total_conc)

# modelo
m1 = glm(total_conc ~ Especie, data = conce_lipi, family = gaussian)
summary(m1)
Anova(m1)
shapiro.test(residuals(m1))
# Estimated marginal means 
lip_compa <- emmeans(m1, 
                     specs = pairwise ~ Especie, 
                     type = "response")
lip_compa
lip_compa.m<-lip_compa$emmean 
lip_compa.m
model_means_cld_lip <- cld(object = lip_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_lip






m1 = aov(total_conc ~ Estatus, data = conce_lipi)
compa6 = TukeyHSD(m1)
compa6
Cld3 = multcompLetters4(m1, compa6)
Cld3

# modelo estadistico
mod_lip = glm(total_conc ~ Especie, data = conce_lipi, family = "gaussian")
#summary(mod_lip)
#Anova(mod_lip)
# comparaciones multiples
em_lip = emmeans(m1, specs = pairwise ~ Especie)
em_lip$emmeans
em_lip$contrasts


#library(lme4)
#mod_lip2 = glmer(lipidos ~ Especie + (1|PlantID), data = lipi,
#                  family = "gaussian")
#summary(mod_lip2)
#Anova(mod_lip2)
# comparaciones multiples
#em_prot2 = emmeans(mod_prot2, specs = pairwise ~ Especie)

# Plot
lipid <- conce_lipi %>%
  ggplot(aes(x = Especie, y = total_conc, fill = Estatus)) +
  geom_boxplot() +
  ## use either geom_point() or geom_jitter()
  geom_point(size = 2, alpha = .5, #
             position = position_jitter(seed = 1, width = .1))+
  #stat_summary(geom = "text", fun.data = n_fun)+
  #coord_flip()+
  labs(x = "Especies", y = "Concentración de lípidos (µg/mg)")+
  scale_x_discrete(labels=c("1CF" = "CF", "2CPF" = "CPF",
                            "3CPP" = "CPP", "4CAS" = "CAS", "5CAA" = "CAA",
                            "6CM" = "CM"))+
  theme_bw()+
  theme(axis.text = element_text(face = "bold"))+
  scale_color_discrete(name="Species")+
  annotate("text", x=1, y=172, label= "ab", size = 5)+
  annotate("text", x=2, y=176, label= "ab", size = 5)+
  annotate("text", x=3, y=151, label= "b", size = 5)+
  annotate("text", x=4, y=155, label= "b", size = 5)+
  annotate("text", x=5, y=140, label= "b", size = 5)+
  annotate("text", x=6, y=189, label= "a", size = 5)+
  #annotate("text", x=1, y=58, label= "n = 24", size = 4)+
  #annotate("text", x=2, y=58, label= "n = 21", size = 4)+
  #annotate("text", x=3, y=58, label= "n = 16", size = 4)+
  #annotate("text", x=4, y=58, label= "n = 34", size = 4)+
  #annotate("text", x=5, y=58, label= "n = 32", size = 4)+
  #annotate("text", x=6, y=58, label= "n = 41", size = 4)+
  theme(legend.position = "none")+
  scale_fill_manual(values = c("#DE7862FF", "#58A449FF"))
lipid  


#### relación proteinas lipidos P:L ####
pl = read.csv("PL.csv", header = T)  
head(pl)  
str(pl)

# Agrupando por individuo
pl_res = pl %>%
  group_by(año, Especie, PlantID, Estatus) %>%
  dplyr::summarize(total_pl = mean(pl), es_pl = es(pl), n = n())
pl_res

tapply(pl_res$total_pl, pl_res$Especie, mean)
tapply(pl_res$total_pl, pl_res$Especie, es)
tapply(pl_res$total_pl, pl_res$Especie, length)
#write.csv(pl_res, file = "pl.csv")
# Agrupando por especie
pl_res2 = pl_res %>%
  group_by(Especie) %>%
  dplyr::summarize(total_pl2 = mean(total_pl), 
                   es_pl2 = es(total_pl), n = n())
pl_res2
View(pl_res2)

#
boxplot(pl_res$total_pl ~ pl_res$Especie)
#boxplot(pl_res$total_pl ~ pl_res$Estatus)
shapiro.test(pl_res$total_pl)
hist(pl_res$total_pl)
# GLM
modpl = glm(total_pl ~ Especie, data = pl_res, family = gaussian)
summary(modpl)
Anova(modpl)
# ANOVA
modpl = aov(total_pl ~ Estatus, data = pl_res)
summary(modpl)

## grafica de boxplot
# Plot
prot_lip <- ggplot(aes(x = Especie, y = total_pl, fill = Estatus),
                   data = pl_res) +
  geom_boxplot() +
  ## use either geom_point() or geom_jitter()
  geom_point(size = 2, alpha = .5, #
             position = position_jitter(seed = 1, width = .1))+
  #stat_summary(geom = "text", fun.data = n_fun)+
  #coord_flip()+
  labs(x = "Especies", y = "P : L")+
  scale_x_discrete(labels=c("1CF" = "CF", "2CPF" = "CPF",
                            "3CPP" = "CPP", "4CAS" = "CAS", "5CAA" = "CAA",
                            "6CM" = "CM"))+
  theme_bw()+
  theme(axis.text = element_text(face = "bold"))+
  scale_color_discrete(name="Species",
                       labels = c("CF", "CPF", "CPP", "CAS", "CAA", "CM"))+
  #annotate("text", x=1, y=187, label= "a", size = 5)+
  #annotate("text", x=2, y=208, label= "a", size = 5)+
  #annotate("text", x=3, y=165, label= "a", size = 5)+
  #annotate("text", x=4, y=182, label= "a", size = 5)+
  #annotate("text", x=5, y=165, label= "a", size = 5)+
  #annotate("text", x=6, y=210, label= "a", size = 5)+
  #annotate("text", x=1, y=0.4, label= "n = 24", size = 4)+
  #annotate("text", x=2, y=0.4, label= "n = 20", size = 4)+
  #annotate("text", x=3, y=0.4, label= "n = 13", size = 4)+
  #annotate("text", x=4, y=0.4, label= "n = 33", size = 4)+
  #annotate("text", x=5, y=0.4, label= "n = 32", size = 4)+
#annotate("text", x=6, y=0.4, label= "n = 41", size = 4)+
theme(legend.position = "none")+
  scale_fill_manual(values = c("#DE7862FF", "#58A449FF"))
prot_lip

# grafica de puntos
ggplot(pl, aes(x = prot, y = lipidos, color = Especie))+
  geom_point()#+
#  geom_smooth(method="lm", se=FALSE)


# haciendo panel de las dos gráficas
library(ggpubr)
# juntado grafica de proteinas, lipidos y P:L
ggarrange(produ, size, prot, lipid, prot_lip, 
          labels = c("A", "B", "C", "D", "E"),
          ncol =3, nrow = 2)

# cargando paqueteria gridExtra
library(gridExtra)
library(cowplot)
gt <- grid.arrange(produ, size, 
                   prot, lipid, prot_lip,
                   ncol = 6, nrow = 2, 
                   layout_matrix = rbind(c(1,1,1,2,2,2),
                                         c(3,3,4,4,5,5)))
# Add labels to the arranged plots
p <- as_ggplot(gt) +                                # transform to a ggplot
  draw_plot_label(label = c("A", "B", "C", "D", "E"), size = 15,
                  x = c(0,0.5,0,0.333,0.666), y = c(1,1,0.5,0.5,0.5))#Add labels
p



##### Rasgos del polen ####
setwd("/home/luis/Documents/3_Doctorado_UNAM/a-proyecto/analisis_florales_tesis_2022/rasgos_polen")
# producción de polen
produccion = read.csv("produ.csv", header = T)
tamaño = read.csv("produ_tam.csv", header = T) #ya tiene la variable
proteinas = read.csv("conce_prot.csv", header = T)
lipidos = read.csv("conce_lipi.csv", header = T)
pl = read.csv("pl.csv", header = T)

# Agrupando por individuos
produccion$anoplant = paste(produccion$año, produccion$id_planta)
proteinas$anoplant = paste(proteinas$año, proteinas$PlantID)
lipidos$anoplant = paste(lipidos$año, lipidos$PlantID)
pl$anoplant = paste(pl$año, pl$PlantID)

# Uniendo tablas
joined_tibble <- full_join(produccion, tamaño,
                           by = join_by(anoplant == anoplant))
joined_tibble2 <- full_join(joined_tibble, proteinas,
                            by = join_by(anoplant == anoplant))
joined_tibble3 <- full_join(joined_tibble2, lipidos,
                            by = join_by(anoplant == anoplant))
joined_tibble4 <- full_join(joined_tibble3, pl,
                            by = join_by(anoplant == anoplant))
# Exportar tabla a csv
write.csv(joined_tibble4, file = "rasgos_pollen.csv")

### análisis multivariado con todos los rasgos evaluados del polen
library(vegan)

# cargando base depurada de todos los rasgos de polen
pollen = read.csv("rasgos_pollen2.csv", header = T)
head(pollen)
str(pollen)

tapply(pollen$produ, pollen$spp, mean)
tapply(pollen$tam, pollen$spp, mean)
tapply(pollen$conc.prot, pollen$spp, mean)
tapply(pollen$conc_lip, pollen$spp, mean)
tapply(pollen$pl, pollen$spp, mean)


pollen2 = pollen[,6:10]
head(pollen2)

# Normalidad multivariada
library(MVN)
# test de normalidad
# test de Mardia en MVN
result <- mvn(data = pollen2, mvnTest = "mardia")
result$multivariateNormality
# Henze-Zirkler's MVN test
result <- mvn(data = pollen2, mvnTest = "hz")
result$multivariateNormality
# Royston's MVN test
result <- mvn(data = pollen2, mvnTest = "royston")
result$multivariateNormality
# Doornik-Hansen's MVN test
result <- mvn(data = pollen2, mvnTest = "dh")
result$multivariateNormality
# Energy test
result <- mvn(data = pollen2, mvnTest = "energy")
result$multivariateNormality


# PCA de caracteres del nectar
head(pollen)
str(pollen)
pairs(pollen[6:10])
pca3 <- prcomp(pollen[, 6:10], scale = T)
summary(pca3)
pca3$rotation[, 1:2]
plot(pca3)
str(pca3)
#write.csv(pca1$rotation[, 1:2], file = "pca_hembras.csv")
biplot(pca3, scale=0)

# cargando paquete factoextra
library(factoextra)
# Top 10 variables que más contribuyen a PC1
fviz_contrib(pca3, choice = "var", axes = 1, top = 10)
fviz_contrib(pca3, choice = "var", axes = 2, top = 10)
# plot
fviz_pca_biplot(pca3, geom.ind = "point",
                axes = c(1,2), pointsize = 2, title = "", geom.var = c("",""),
)

# Variables
fviz_pca_var(pca3, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución
fviz_pca_var(pca3, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

### Graph of individuals (rows)
ind = get_pca_ind(pca3)
ind

fviz_pca_ind(pca3)
fviz_pca_ind(pca3, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)

fviz_pca_ind(pca3, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca3, choice = "ind", axes = 1:2)

# Agrupado por condición
fviz_pca_ind(pca3,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = pollen$condicion, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Groups"
)

# Agrupado por especie
fviz_pca_ind(pca3,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = pollen$spp, # color by groups
             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
                         "#E7B850", "#FC4E50"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "confidence",
             legend.title = "Groups"
)

### agrupado por condición + las variables
fviz_pca_biplot(pca3,
                col.ind = pollen$condicion, palette = "jco",
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Condition"
)

### agrupado por especies + las variables
fviz_pca_biplot(pca1,
                col.ind = hem_resu2$especies,
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Species"
)



# cargando paquete para graficar PCA
library(ggfortify)
autoplot(pca3)
pca_hem = autoplot(pca3, data = pollen, colour = "condicion", size = 2)+
  xlab("PC 1 (36.1%)") +
  ylab("PC 2 (31.35%)") +
  scale_color_discrete(name = "Condition",
                       labels = c("Domesticated", "Wild"))+
  theme_bw()
pca_hem


set.seed(0)#Para que los resultados no se brinden aleatorios
nmds1 <- metaMDS(pollen[,6:10])
plot(nmds1)
plot(nmds1, type = "t")
stressplot(nmds1)

coordenadas <- as.data.frame(scores(nmds1)$sites)
coordenadas

#Le añadimos a las coordenadas una columna con los tramos:
coordenadas$spp = pollen$spp
coordenadas$condicion = pollen$condicion
head(coordenadas)
# plot
gr2 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
  geom_point(size = 4, aes(colour = spp))+
  theme_bw()+
  scale_color_discrete(name = "Species", 
                       labels =c("CF","CPF","CPP","CAS","CAA","CM") );gr2

#+geom_text(hjust=0.5, vjust=1.5, label=datos$sample)
gr3 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
  geom_point(size = 4, aes(colour = condicion))+
  theme_bw()+
  scale_color_discrete(name = "condicion", 
                       labels =c("Domesticada","Silvestre") );gr3
#gr4 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
#  geom_point(size = 4, aes( shape = sexo_flor, colour = spp)); gr4
# haciendo panel de las dos gráficas

# PCoA
pol_dist2 = dist(pollen[,c(6:10)])
pol_PCoA <- wcmdscale(d = pol_dist2, eig = TRUE)
pol_PCoA
pol_PCoA$points
# gráfica del PCoA
ggplot(data = data.frame(pol_PCoA$points),
       aes(x = Dim1, y = Dim2)) +
  geom_point() +
  theme_bw()
#
pcoa <- cmdscale(pol_dist2, eig = TRUE, add = TRUE)
#convert pcoa results into data frame that can be plotted
pcoa_df <- data.frame(pcoa$points)
colnames(pcoa_df) <- c("PCo1", "PCo2")
pcoa_df$Species <- factor(pollen$spp) #add group of interest,
# mine was Morphospecies in the data frame cal_fem_data2
calf <- ggplot(pcoa_df, aes(x = PCo1, y = PCo2, color = Species)) + 
  geom_point(size = 2) +
  xlab("PCo1") +
  ylab("PCo2") + 
  ggtitle("Flores macho") +
  theme_classic()
calf
#
pcoa1 <- cmdscale(pol_dist2, eig = TRUE, add = TRUE)
#convert pcoa results into data frame that can be plotted
pcoa1_df <- data.frame(pcoa1$points)
colnames(pcoa1_df) <- c("PCo1", "PCo2")
pcoa1_df$condicion <- factor(pollen$condicion) #add group of interest,
# mine was Morphospecies in the data frame cal_fem_data2
calf <- ggplot(pcoa1_df, aes(x = PCo1, y = PCo2, color = condicion)) + 
  geom_point(size = 2) +
  xlab("PCo1") +
  ylab("PCo2") + 
  #ggtitle("Flores macho por condición") +
  theme_classic()+
  scale_color_discrete(name = "Condition", labels = c("Domesticated", "Wild"))
calf

# PERMANOVA
library(vegan)
head(pollen)
str(pollen)
dune8 = pollen[6:10]
# Calculando distancia euclidiana
dune.dist5 <- vegdist(dune5, method="euclidean")

set.seed(0)
# calculando PERMANOVA por condición
dune.div8 <- adonis2(dune8 ~ condicion, data = pollen,
                     permutations = 999, method="euclidean")
dune.div8

# calculando PERMANOVA por especie
dune.div9 <- adonis2(dune8 ~ condicion+spp, data = pollen,
                     permutations = 999, method="euclidean")
dune.div9




