# In this script I show analysis of floral traits from Cucurbita species 
# evaluated in this study. I also analyze sugar and amino acid concentration
# between species. Additionally, I evaluate pollen traits.

#### Functions I use in the analysis ####
# function to obtain standard error
es <- function(x){
  sd(x) / sqrt(length(x))
}
# function to obtain coefficient of variance
cv <- function(x){
  (sd(x)/mean(x))*100
}

#### Package to use ####
library(car)
library(MASS)
library(lme4)
#library(nlme)
#library(fitdistrplus)
library(ggplot2)
library(ggsignif)
library(forcats)
library(dplyr)
library(emmeans)
library(multcomp)
#install.packages("multcompView")
library(multcompView)
library(tidyr)

#### Set up directory in which the databases are located ####
setwd("/home/luis/Documents/3_Doctorado_UNAM/manuscrito_1/data_variables")
#### Cargando base de datos de caracteres florales de flores hembra ####
hembras <- read.csv("flores_hembra.csv", header = T)
head(hembras)
str(hembras)
tapply(hembras$CD, list(hembras$especie, hembras$sitio), length)
tapply(hembras$CD, hembras$sitio, length)

### Subset of Morelia flowers
hembras = subset(hembras, sitio == "morelia")
head(hembras)
str(hembras)
tapply(hembras$CD, hembras$especie, length)


# clustering by plant ID
hem_resu <- hembras %>%
  group_by(año,condición,especie2,especie,id_planta2) %>%
  dplyr::summarize(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
                   TD2 = mean(TD2), TD3 = mean(TD3), NDf = mean(NDf), SD = mean(SD),
                   PL = mean(PL), SL = mean(SL), OL = mean(OL), OD = mean(OD), 
                   VN = mean(vol_nec), n = n())

hem_resu2 <- as.data.frame(hem_resu)
str(hem_resu2)
tapply(hem_resu2$CD, hem_resu2$especie, length)
#write.csv(hem_resu2, file="hem_resu.csv")

#### Descriptive statistics of pistillate floral traits ####
# Mean
media = hem_resu2 %>%
  group_by(especie) %>%
  dplyr::summarize(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
                   TD2 = mean(TD2), TD3 = mean(TD3), NDf = mean(NDf), SD = mean(SD),
                   PL = mean(PL), SL = mean(SL), OL = mean(OL), OD = mean(OD), 
                   VN = mean(VN),n = n())
View(media)
#write.csv(media, file = "hembras_mean.csv")
# Standard error
erro = hem_resu2 %>%
  group_by(especie) %>%
  dplyr::summarize(CD = es(CD), TL = es(TL), CL = es(CL), TD1 = es(TD1), 
                   TD2 = es(TD2), TD3 = es(TD3), NDf = es(NDf), SD = es(SD), 
                   PL = es(PL), SL = es(SL), OL = es(OL), OD = es(OD), 
                   VN = es(VN), n = n())
View(erro)
# Coefficient of variation
CV = hem_resu2 %>%
  group_by(especie) %>%
  dplyr::summarize(CD = cv(CD), TL = cv(TL), CL = cv(CL), TD1 = cv(TD1),
                   TD2 = cv(TD2), TD3 = cv(TD3), NDf = cv(NDf), SD = cv(SD), 
                   PL = cv(PL), SL = cv(SL), OL = cv(OL), OD = cv(OD),
                   VN = cv(VN), n = n())
View(CV)

#### Principal component analysis (PCA) of pistillate's floral traits ####
# First 6 lines of the database
head(hem_resu2)
str(hem_resu2)
# plotting variables with pairs
pairs(hem_resu2[6:17])
# Performing the PCA with the "prcomp" function
pca1 <- prcomp(hem_resu2[, 6:17], scale = T)
# information generated by the PCA
summary(pca1)
pca1$rotation[, 1:2]
plot(pca1)
# visualization of PCA
biplot(pca1, scale=0)

# Loading libraries to plot PCAs
library(FactoMineR)
library(factoextra)

# Obtaining information on the eigenvalues of the PCA
get_eigenvalue(pca1)
# percentage of variance explained by each component of the PCA
fviz_eig(pca1, addlabels = T)
# Information obtained from the variables we use for the PCA
var = get_pca_var(pca1); var

# Visualizing variables from PCA
fviz_pca_var(pca1, col.var = "black")
# Quality of the representation of the variables in the factor map
head(var$cos2)

# Loading package "corrplot" to visualize correlations
library(corrplot)
# Correlations between variables (cos2)
corrplot(var$cos2, is.corr = F)
# Visualizing the quality of the representation, which variables are best 
# represented.
fviz_cos2(pca1, choice = "var", axes = 1:2)
fviz_pca_var(pca1, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribution of each variable
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca1, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca1, choice = "var", axes = 2, top = 10)
# Contribution of the variables adding the 2 components
fviz_contrib(pca1, choice = "var", axes = 1:2, top = 10)
# PCA plot of the variables colored by contribution 
fviz_pca_var(pca1, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)


### Graph of individuals (rows)
ind = get_pca_ind(pca1)
# Elements that can be taken out of the ind
ind
# Visualizing the individuals in the PCA plot
fviz_pca_ind(pca1)
# Visualizing the individuals in the PCA as a function of cos2
fviz_pca_ind(pca1, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Visualizing the individuals in the PCA as a function of cos2
fviz_pca_ind(pca1, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Total contribution on PC1 and PC2
fviz_contrib(pca1, choice = "ind", axes = 1:2)


# Clustering by species
hem_resu2 <- hem_resu2 %>%
  mutate(especie2 = fct_relevel(especie2,
                                "CF","CPF", "CAS", "CPP", "CAA", "CM"))
pca_hembras <- fviz_pca_ind(pca1,
             #geom.ind = "point", # show points only (nbut not "text")
             habillage = hem_resu2$especie2, # color by groups
            palette = "Dark2",
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
            #ellipse.level = 0.95,
            legend.title = "Species",
            title = "",
            pointshape = 19,
            pointsize = 1.5,
            label = "none"
)+
  labs(x = "PC 1 (67.8%)", y = "PC 2 (13.3%)")
  #theme(legend.position = "none")

pca_hembras

### PERMANOVA of pistillate flowers
library(vegan)
head(hem_resu2)
str(hem_resu2)
dune5 = hem_resu2[6:17]
# calculating PERMANOVA by species
set.seed(0)
dune.div6 <- adonis2(dune5 ~ especie, data = hem_resu2,
                     permutations = 999, method="euclidean")
dune.div6

# calculando beta dispersión (homogeneidad de varianzas)
bd <- betadisper(dune.dist5, hem_resu2$condición)
anova(bd)
permutest(bd)
plot(bd, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=hem_resu2$especie)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


#### Database of floral traits of staminate flowers of Cucurbita species ####
machos <- read.csv("flores_macho.csv", header = T)
head(machos)
str(machos)
tapply(machos$CD, list(machos$especie, machos$sitio), length)
tapply(machos$CD, machos$sitio, length)

# subset of Morelia flowers
machos = subset(machos, sitio == "morelia")
str(machos)

# Clustering by plant ID
machos2 = machos %>%
  group_by(año, condicion, especie, especie2, id_planta) %>%
  summarise(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
            TD2 = mean(TD2), TD3 = mean(TD3), NDm = mean(NDm), AD = mean(AD),
            StL = mean(StL), AL = mean(AL), VN = mean(vol_nec), n = n())
str(machos2)
tapply(machos2$CD, machos2$especie2, length)
#View(machos2)
#write.csv(machos2, file = "machos2_prom.csv")


#### Descriptive statistics of staminate flowers ####
# Mean
machos3 = machos2 %>%
  group_by(especie) %>%
  summarise(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
            TD2 = mean(TD2), TD3 = mean(TD3), NDm = mean(NDm), AD = mean(AD),
            StL = mean(StL), AL = mean(AL), VN = mean(VN), n = n())
# exporting mean by floral trait
#write.csv(machos3, file = "machos_mean.csv")
View(machos3)


# Standard error
erro_m = machos2 %>%
  group_by(especie) %>%
  summarise(CD = es(CD), TL = es(TL), CL = es(CL), TD1 = es(TD1), 
            TD2 = es(TD2), TD3 = es(TD3), NDm = es(NDm), AD = es(AD), 
            StL = es(StL), AL = es(AL), VN = es(VN), n = n())
View(erro_m)
# Coefficient of variance
cv_m = machos2 %>%
  group_by(especie) %>%
  summarise(CD = cv(CD), TL = cv(TL), CL = cv(CL), TD1 = cv(TD1),
            TD2 = cv(TD2), TD3 = cv(TD3), NDm = cv(NDm), AD = cv(AD), 
            StL = cv(StL), AL = cv(AL), VN = cv(VN), n = n())

#### Principal component analysis (PCA) of staminate floral traits ####
head(machos2)
machos2 = as.data.frame(machos2)
str(machos2)
pairs(machos2[6:15])
pca2 <- prcomp(machos2[, 6:15], scale = T)
summary(pca2)
pca2$rotation[, 1:2]
#write.csv(pca1$rotation[, 1:2], file = "pca_hembras.csv")
plot(pca2)
biplot(pca2, scale=0)

# Obteniendo información sobre los eigenvalues del PCA
get_eigenvalue(pca2)
# porcentaje de varianza explicada por cada componente del PCA
fviz_eig(pca2, addlabels = T)
# Información que se obtiene de las variables que usamos para el PCA
var = get_pca_var(pca2); var

# Visualizando las variables del PCA
fviz_pca_var(pca2, col.var = "black")
# Calidad de la representación de las variables en el mapa de factores
head(var$cos2)
# Correlaciones entre calidades (cos2)
corrplot(var$cos2, is.corr = F)
# Visualizando la calidad de la representación, que variables estan mejor
# representadas. Grafica de barras y mapa de factores
fviz_cos2(pca2, choice = "var", axes = 1:2)
fviz_pca_var(pca2, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución de cada variable
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca2, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca2, choice = "var", axes = 2, top = 10)
# Contribución de las variables sumando los 2 componentes
fviz_contrib(pca2, choice = "var", axes = 1:2, top = 10)
# Gráfica de PCA de las variables coloreando por contribución 
fviz_pca_var(pca2, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

### Gráfica de individuos (filas)
ind = get_pca_ind(pca2)
# Elementos que se pueden sacar de los ind
ind
# Visualizando los individuos en el grafico de PCA
fviz_pca_ind(pca2)
# Visualizando los individuos en el PCA en función de cos2
fviz_pca_ind(pca2, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Visualizando los individuos en el PCA en funcións de cos2
fviz_pca_ind(pca2, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Total contribution on PC1 and PC2
fviz_contrib(pca2, choice = "ind", axes = 1:2)


# Clustering by species

machos2 <- machos2 %>%
  mutate(especie2 = fct_relevel(especie2,
                    "CF","CPF", "CAS", "CPP", "CAA", "CM"))
pca_machos <- 
  fviz_pca_ind(pca2,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = machos2$especie2, # color by groups
             palette = "Dark2",
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
             legend.title = "Species",
             title = "",
             pointshape = 19,
             pointsize = 1.5,
             #label = "none"
)+
  labs(x = "PC 1 (53.2%)", y = "PC 2 (21.9%)")
 #theme(legend.position = "none")


pca_hembras
pca_machos

# code to paste graphs
# loading packages
library(gridExtra)
library(cowplot)
library(ggpubr)
# joining plots
gt <- ggarrange(pca_hembras, pca_machos,
                ncol = 1, nrow = 2, common.legend = TRUE, legend = "right",
                labels="AUTO")
gt
# Exporting plot
ggsave("Figure_1.png", device = "png", width = 172, height = 172,
       units = "mm", dpi = 600, bg = "white")


### PERMANOVA of staminate flowers
head(machos2)
str(machos2)
dune6 = machos2[6:15]
# Calculando distancia euclidiana
set.seed(0)
# calculando PERMANOVA por especie
dune.div7 <- adonis2(dune6 ~ especie, data = machos2,
                     permutations = 999, method="euclidean")
dune.div7

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


#### Nectar volume ####
# Loading nectar volume combined database
volumen = read.csv("nectar_volume.csv", header = T)
head(volumen)
str(volumen)
# Descriptive statistics
tapply(volumen$VN, list(volumen$especie, volumen$sexo), mean)
tapply(volumen$VN, list(volumen$especie, volumen$sexo), es)
tapply(volumen$VN, list(volumen$especie, volumen$sexo), length)


# GLM of nectar volume by species and floral sex
volu = glm(log(VN) ~ especie*sexo, data = volumen, family = gaussian)
summary(volu) #, dispersion=1
Anova(volu)
shapiro.test(residuals(volu))
plot(residuals(volu))
volu_compa <- emmeans(volu, 
                      specs = pairwise ~ especie | sexo, 
                      type = "response")
volu_compa
volu_compa.m<-volu_compa$emmean 
volu_compa.m
model_means_cld_volu <- cld(object = volu_compa.m,
                            adjust = "sidak",
                            Letter = letters, 
                            alpha = 0.05)
model_means_cld_volu


# GLM with Gamma distribution
volu2 = glm(VN ~ especie*sexo, data = volumen, family = Gamma)
summary(volu2) #, dispersion=1
Anova(volu2)
shapiro.test(residuals(volu2))
plot(residuals(volu2))


#### Nectar sugar concentrations ####
azucares = read.csv("azucares_2022.csv", header = T)
head(azucares)
str(azucares)

# Extrayendo los valores de morelia
azucares_more = subset(azucares, sitio == "morelia")
str(azucares_more)
head(azucares_more)
tapply(azucares_more$Suma.total, list(azucares_more$spp,
                                      azucares_more$sexo), length)
# eliminar los 2 datos de CF de flores macho
azucares_more2 = subset(azucares_more, spp != "1CF")
str(azucares_more2)
tapply(azucares_more2$Suma.total, list(azucares_more2$spp,
                                       azucares_more2$sexo), length)

# Descriptive statistics of total sugar concentration
tapply(azucares_more2$Suma.total, list(azucares_more2$spp,
                                       azucares_more2$sexo), mean)
tapply(azucares_more2$Suma.total, list(azucares_more2$spp,
                                       azucares_more2$sexo), es)

# Descriptive statistics of fructose concentration
tapply(azucares_more2$fructosa, list(azucares_more2$spp,
                                     azucares_more2$sexo), mean)
tapply(azucares_more2$fructosa, list(azucares_more2$spp,
                                     azucares_more2$sexo), es)

# Descriptive statistics of glucose concentration
tapply(azucares_more2$glucosa, list(azucares_more2$spp,
                                    azucares_more2$sexo), mean)
tapply(azucares_more2$glucosa, list(azucares_more2$spp,
                                    azucares_more2$sexo), es)

# Descriptive statistics of sucrose concentration
tapply(azucares_more2$sacarosa, list(azucares_more2$spp,
                                     azucares_more2$sexo), mean)
tapply(azucares_more2$glucosa, list(azucares_more2$spp,
                                    azucares_more2$sexo), es)

# Separando flores hembra
# histogramas de cada azucar
hist(azucares_more2$fructosa)
hist(azucares_more2$glucosa)
hist(azucares_more2$sacarosa)
hist(azucares_more2$Suma.total)
# prueba de normalidad
shapiro.test(azucares_more2$fructosa) # no normal
shapiro.test(azucares_more2$glucosa) # no normal
shapiro.test(azucares_more2$sacarosa)
shapiro.test(azucares_more2$Suma.total)
# modelado de distribucion
boxplot(azucares_more2$fructosa ~ azucares_more2$spp)#azucares_more2$sexo + 
boxplot(azucares_more2$glucosa ~ azucares_more2$spp)
boxplot(azucares_more2$sacarosa ~ azucares_more2$spp)
boxplot(azucares_more2$Suma.total ~ azucares_more2$spp)

# glm of fructose
hem_fruc = glm(fructosa ~ spp*sexo, data = azucares_more2, family = Gamma)
summary(hem_fruc)
Anova(hem_fruc)
shapiro.test(residuals(hem_fruc))
# comparaciones multiples
fru_compa <- emmeans(hem_fruc, 
                     specs = pairwise ~ spp | sexo, 
                     type = "response")
fru_compa
fru_compa.m<-fru_compa$emmean 
fru_compa.m
model_means_cld_fru <- cld(object = fru_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_fru

# glm of glucose
hem_glu = glm(glucosa ~ spp*sexo, data = azucares_more2, family = Gamma)
summary(hem_glu)
Anova(hem_glu)
shapiro.test(residuals(hem_glu))
# comparaciones multiples
glu_compa <- emmeans(hem_glu, 
                     specs = pairwise ~ spp | sexo, 
                     type = "response")
glu_compa
glu_compa.m<-glu_compa$emmean 
glu_compa.m
model_means_cld_glu <- cld(object = glu_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_glu

### glm de SACAROSA
hem_sac = glm(sacarosa ~ spp*sexo, data = azucares_more2, family = gaussian)
summary(hem_sac)
Anova(hem_sac)
shapiro.test(residuals(hem_sac))
plot(residuals(hem_sac))
# comparaciones multiples
sac_compa <- emmeans(hem_sac, 
                     specs = pairwise ~ spp | sexo, 
                     type = "response")
sac_compa
sac_compa.m<-sac_compa$emmean 
sac_compa.m
model_means_cld_sac <- cld(object = sac_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_sac

### glm de AZUCAR TOTAL
hem_total = glm(Suma.total ~ spp*sexo, data = azucares_more2, family = gaussian)
summary(hem_total)
Anova(hem_total)
shapiro.test(residuals(hem_total))
plot(residuals(hem_total))
# comparaciones multiples
total_compa <- emmeans(hem_total, 
                       specs = pairwise ~ spp | sexo, 
                       type = "response")
total_compa
total_compa.m<-total_compa$emmean 
total_compa.m
model_means_cld_total <- cld(object = total_compa.m,
                             adjust = "tukey",
                             Letter = letters, 
                             alpha = 0.05)
model_means_cld_total



##### PCA de aminoacidos de flores hembra #####
amino = read.csv("concentraciones_aminoacidos.csv", header = TRUE)
str(amino)
head(amino)
tapply(amino$Asp, list(amino$spp,amino$sexo_flor), length)
tapply(amino$Asp, list(amino$condición, amino$sexo_flor), mean)

# concentración de aminoacidos en flores hembra
amino_hem = subset(amino, sexo_flor == "H")
str(amino_hem)
# analisis multivariado de normalidad
mvn(amino_hem[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")

# concentración de aminoacidos en flores hembra
amino_mac = subset(amino, sexo_flor == "M")
str(amino_mac)
# analisis multivariado de normalidad
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")

# PCA de caracteres del néctar de flores hembra
# visualizando todas las combinaciones entre las variables
pairs(amino_hem[8:24], lower.panel = NULL)
# Calculando el PCA para flores hembra
pca4 = prcomp(amino_hem[8:24], scale = T)
summary(pca4)
# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca4)
# calculando la varianza explicada por cada componente
fviz_eig(pca4, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca4); var
# Visualización de las variables
fviz_pca_var(pca4, col.var = "black")

# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca4, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca4, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca4, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca4, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca4, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca4, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

### Graph of individuals (rows)
ind = get_pca_ind(pca4)
ind

fviz_pca_ind(pca4)
# Visualizando los individuos por cos2
fviz_pca_ind(pca4, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca4, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca4, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino_hem$condición, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2
)+
 labs(x = "PC 1 (63.5%)", y = "PC 2 (11.8%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino_hem$condición, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2,
             label = "none"
)+
  labs(x = "PC 1 (63.5%)", y = "PC 2 (11.8%)")


# Agrupado por especie
#fviz_pca_ind(pca4,
#             geom.ind = "point", # show points only (nbut not "text")
#             col.ind = nectar_h$spp, # color by groups
#             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
#                         "#E7B850"),
#             addEllipses = TRUE, # Concentration ellipses
#             #ellipse.type = "confidence",
#             legend.title = "Groups"
#)

### agrupado por condición + las variables
#fviz_pca_biplot(pca4,
#                col.ind = nectar_h$condicion, palette = "jco",
#                addEllipses = TRUE, label = "var",
#                col.var = "black", repel = TRUE,
#                legend.title = "Condition"
#)

library(MVN)
# Flores hembra
mvn(amino_hem[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")



# Flores macho
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# PERMANOVA de aminoacidos de flores hembra
str(amino_hem)
amino_hem[8:24]
dune8 = amino_hem[8:24]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div8 <- adonis2(dune8 ~ condición, data = amino_hem,
                     permutations = 999, method="euclidean")
dune.div8

# calculando PERMANOVA por especie
dune.div8 <- adonis2(dune8 ~ spp, data = nectar_h,
                     permutations = 999, method="euclidean")
dune.div8

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse

#### PCA DE AMINOACIDOS DE FLORES MACHO ####
# concentración de aminoacidos en flores MACHO
amino_mac = subset(amino, sexo_flor == "M")
str(amino_mac)
# analisis multivariado de normalidad
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")

# PCA de caracteres del néctar de flores hembra
# visualizando todas las combinaciones entre las variables
pairs(amino_mac[8:24], lower.panel = NULL)
# Calculando el PCA para flores hembra
pca5 = prcomp(amino_mac[8:24], scale = T)
summary(pca5)
# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca5)
# calculando la varianza explicada por cada componente
fviz_eig(pca5, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca5); var
# Visualización de las variables
fviz_pca_var(pca5, col.var = "black")

# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca5, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca5, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca5, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca5, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca5, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca5, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)


### Graph of individuals (rows)
ind = get_pca_ind(pca5)
ind

fviz_pca_ind(pca5)
# Visualizando los individuos por cos2
fviz_pca_ind(pca5, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca5, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca5, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca5,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino_mac$condición, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2
)+
 labs(x = "PC 1 (61.7%)", y = "PC 2 (12.3%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca5,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino_mac$condición, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2,
             label = "none"
)+
  labs(x = "PC 1 (61.7%)", y = "PC 2 (12.3%)")


# Agrupado por especie
#fviz_pca_ind(pca4,
#             geom.ind = "point", # show points only (nbut not "text")
#             col.ind = nectar_h$spp, # color by groups
#             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
#                         "#E7B850"),
#             addEllipses = TRUE, # Concentration ellipses
#             #ellipse.type = "confidence",
#             legend.title = "Groups"
#)

### agrupado por condición + las variables
#fviz_pca_biplot(pca4,
#                col.ind = nectar_h$condicion, palette = "jco",
#                addEllipses = TRUE, label = "var",
#                col.var = "black", repel = TRUE,
#                legend.title = "Condition"
#)

library(MVN)
# Flores macho
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# PERMANOVA de aminoacidos de flores hembra
str(amino_mac)
amino_mac[8:24]
dune9 = amino_mac[8:24]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div9 <- adonis2(dune9 ~ condición, data = amino_mac,
                     permutations = 999, method="euclidean")
dune.div9

# calculando PERMANOVA por especie
dune.div8 <- adonis2(dune8 ~ spp, data = nectar_h,
                     permutations = 999, method="euclidean")
dune.div8

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


#### AMINOACIDOS DEL NECTAR FLORAL DE CUCURBITA ####
amino = read.csv("concentraciones_aminoacidos.csv", header = TRUE)
str(amino)
head(amino)
tapply(amino$Asp, list(amino$spp,amino$sexo_flor), length)

# media de cada aminoacido por especie
amino2 = amino %>%
  group_by(spp, sexo_flor)  %>%
  dplyr::summarize(Asp2 = mean(Asp), Glu2 = mean(Glu), Ser2 = mean(Ser),
                   His2 = mean(His), Gly2 = mean(Gly), Thr2 = mean(Thr),
                   Arg2 = mean(Arg), Ala2 = mean(Ala), Tyr2 = mean(Tyr),
                   Cys2 = mean(Cys), Val2 = mean(Val), Met2 = mean(Met),
                   Phe2 = mean(Phe), Ile2 = mean(Ile), Leu2 = mean(Leu),
                   Lys2 = mean(Lys), Pro2 = mean(Pro), n = n())
amino2
View(amino2)
#write.csv(amino2, file = "amino_mean.csv")
# error estandar de cada aminoacido por especie
amino3 = amino %>%
  group_by(condición, sexo_flor)  %>%
  dplyr::summarize(Asp2 = es(Asp), Glu2 = es(Glu), Ser2 = es(Ser),
                   His2 = es(His), Gly2 = es(Gly), Thr2 = es(Thr),
                   Arg2 = es(Arg), Ala2 = es(Ala), Tyr2 = es(Tyr),
                   Cys2 = es(Cys), Val2 = es(Val), Met2 = es(Met),
                   Phe2 = es(Phe), Ile2 = es(Ile), Leu2 = es(Leu),
                   Lys2 = es(Lys), Pro2 = es(Pro), n = n())

amino3
View(amino3)
amino3 = as.data.frame(amino2)
str(amino3)
write.csv(amino3, file = "amino_condicion.csv")

# Filtering values of C. foetidissima because there are only 2 values
tapply(amino$Asp, list(amino$spp,amino$sexo_flor), length)
amino2 = subset(amino, spp != "1CF")
str(amino2)


# loading libraries
library(FactoMineR)
library(factoextra)

### PCA of amino acids by species and floral sex
head(amino)
str(amino)
pairs(amino[8:24])
# PCA de caracteres del néctar de flores hembra
# visualizando todas las combinaciones entre las variables
pairs(amino[8:24], lower.panel = NULL)
# Calculando el PCA para flores hembra
pca4 = prcomp(amino[8:24], scale = T)
summary(pca4)
# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca4)
# calculando la varianza explicada por cada componente
fviz_eig(pca4, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca4); var
# Visualización de las variables
fviz_pca_var(pca4, col.var = "black")

library(corrplot)
# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca4, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca4, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca4, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca4, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca4, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca4, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

# Solo caracteres del nectar
#fviz_pca_var(pca4, col.var = factor(c("nectar","nectar","nectar",
#                                      "nectar","nectar","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid")), 
#             palette = c("#0073C2FF", "#EFC000FF"),
#             legend.title = "Cluster")

### Graph of individuals (rows)
ind = get_pca_ind(pca4)
ind

fviz_pca_ind(pca4)
# Visualizando los individuos por cos2
fviz_pca_ind(pca4, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca4, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca4, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino$sexo_flor, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2
)+
  labs(x = "PC 1 (54%)", y = "PC 2 (12.7%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino$sexo_flor, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
             legend.title = "Condition",
             title = "",
             pointshape=21,
             pointsize = 2,
             label = "none"
)+
  labs(x = "PC 1 (54%)", y = "PC 2 (12.7%)")


# Agrupado por especie
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = amino2$spp, # color by groups
             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
                         "#E7B850"),
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "confidence",
             legend.title = "Groups"
)

### agrupado por condición + las variables
fviz_pca_biplot(pca4,
                col.ind = nectar_h$condicion, palette = "jco",
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Condition"
)

library(MVN)
# Flores hembra
mvn(nectar_h[8:29], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")
mvn(nectar_h[8:12], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# Flores macho
mvn(nectar_m[8:29], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# PERMANOVA del nectar de flores hembra
library(vegan)
str(amino)
amino[8:24]
dune8 = amino[8:24]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div8 <- adonis2(dune8 ~ spp*sexo_flor, by="terms", data = amino,
                     permutations = 999, method="euclidean")
dune.div8

# calculando PERMANOVA por especie
dune.div8 <- adonis2(dune8 ~ sexo_flor, data = amino,
                     permutations = 999, method="euclidean")
dune.div8

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse

# MANOVA del nectar
# MANOVA test
mod1<-manova(cbind(fructose, glucose, sucrose) ~ condicion, 
             data = nectar_h)
summary(mod1) #Diferencias significativas







# cargando paquete factoextra
library(factoextra)
# Top 10 variables que más contribuyen a PC1
fviz_contrib(pca4, choice = "var", axes = 1, top = 10)
fviz_contrib(pca4, choice = "var", axes = 2, top = 10)
# plot
fviz_pca_biplot(pca4, geom.ind = "point",
                axes = c(1,2), pointsize = 2, title = "", geom.var = c("",""),
)

# cargando paquete para graficar PCA
library(ggfortify)
autoplot(pca4)
pca_ami1 = autoplot(pca4, data = amino, colour = "condición", size = 2)+
  xlab("PC 1 (55.7%)") +
  ylab("PC 2 (11%)") +
  scale_color_discrete(name = "Condición",
                       labels = c("Domesticadas", "Silvestres"))+
  theme_bw()
pca_ami1
# aminoacidos por sexo
pca_ami2 = autoplot(pca4, data = amino, colour = "sexo_flor", size = 2)+
  xlab("PC 1 (55.7%)") +
  ylab("PC 2 (11%)")+
  scale_color_discrete(name = "Sexo floral",
                       labels = c("Hembras", "Machos"))+
  theme_bw()
pca_ami2

# Normalidad multivariada
library(MVN)
# test de normalidad
# test de Mardia en MVN
result <- mvn(data = amino[8:24], mvnTest = "mardia")
result$multivariateNormality
# Henze-Zirkler's MVN test
result <- mvn(data = amino[8:24], mvnTest = "hz")
result$multivariateNormality
# Royston's MVN test
result <- mvn(data = amino[8:24], mvnTest = "royston")
result$multivariateNormality
# Doornik-Hansen's MVN test
result <- mvn(data = amino[8:24], mvnTest = "dh")
result$multivariateNormality
# Energy test
result <- mvn(data = amino[8:24], mvnTest = "energy")
result$multivariateNormality






#library(devtools)
#install_github("vqv/ggbiplot")
library(ggbiplot)
ca.condicion3 = amino[,3]
ca.species3 = amino[, 4]
ca.sex3 = amino[,6]

#
ggbiplot(pca3)
# PCA por condición
ggbiplot(pca3, obs.scale = 1, var.scale = 1, 
         groups = ca.condicion3, ellipse = F, 
         circle = F) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', 
        legend.position = 'bottom')
# PCA por especie
ggbiplot(pca3, obs.scale = 1, var.scale = 1, 
         groups = ca.species3, ellipse = F, 
         circle = F) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', 
        legend.position = 'bottom')
# PCA por sexo
ggbiplot(pca3, obs.scale = 1, var.scale = 1, 
         groups = ca.sex3, ellipse = F, 
         circle = F) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', 
        legend.position = 'bottom')

# PCoA con vegan
library(vegan)
cucu_dist = dist(amino[,c(8:24)])
cucu_PCoA <- wcmdscale(d = cucu_dist, eig = TRUE)
cucu_PCoA
cucu_PCoA$points
# gráfica del PCoA
ggplot(data = data.frame(cucu_PCoA$points),
       aes(x = Dim1, y = Dim2)) +
  geom_point() +
  theme_bw()

# PCoA por condición
pcoa <- cmdscale(cucu_dist, eig = TRUE, add = TRUE)
#convert pcoa results into data frame that can be plotted
pcoa_df <- data.frame(pcoa$points)
colnames(pcoa_df) <- c("PCo1", "PCo2")
pcoa_df$condi <- factor(amino$condición) #add group of interest,
# mine was Morphospecies in the data frame cal_fem_data2
calf1 <- ggplot(pcoa_df, aes(x = PCo1, y = PCo2, color = condi)) + 
  geom_point(size = 1) +
  xlab("PCo1") +
  ylab("PCo2") + 
  ggtitle("") +
  theme_classic()+
  scale_color_discrete(name="Condition",
                       labels = c("Domesticated", "Wild"))

calf1
# PCoA agrupado por sexo floral
pcoa1 <- cmdscale(cucu_dist, eig = TRUE, add = TRUE)
#convert pcoa results into data frame that can be plotted
pcoa1_df <- data.frame(pcoa1$points)
colnames(pcoa1_df) <- c("PCo1", "PCo2")
pcoa_df$sexo <- factor(amino$sexo_flor) #add group of interest,
# mine was Morphospecies in the data frame cal_fem_data2
calf2 <- ggplot(pcoa_df, aes(x = PCo1, y = PCo2, color = sexo)) + 
  geom_point(size = 1) +
  xlab("PCo1") +
  ylab("PCo2") + 
  ggtitle("") +
  theme_classic()+
  scale_color_discrete(name = "Floral sex", labels = c("Female", "Male"))
calf2

# haciendo panel de las dos gráficas
library(ggpubr)
# juntado calf1 y calf2
ggarrange(calf1, calf2, 
          labels = c("A", "B"),
          ncol = 1, nrow = 2)
# exportando plot
ggsave("amino_sex.jpg", device = "jpg", width = 11.5, height = 11.5,
       units = "cm", dpi = 300)





### PERMANOVA DE LOS DIFERENTES AMINOACIDOS
library(vegan)
head(amino)
amino$tratamiento
dune5 = amino[8:24]
# Calculando distancia euclidiana
dune.dist5 <- vegdist(dune5, method="euclidean")

# calculando PERMANOVA por condición
dune.div5 <- adonis2(dune5 ~ condición*sexo_flor, data = amino,
                     permutations = 999, method="euclidean")
dune.div5

# calculando PERMANOVA por especie
dune.div6 <- adonis2(dune5 ~ sexo_flor, data = amino,
                     permutations = 999, method="euclidean")
dune.div6

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse

#### NMDS con los datos de aminoacidos ####
library(vegan)
str(amino)
head(amino)

set.seed(0)#Para que los resultados no se brinden aleatorios
nmds1 <- metaMDS(amino[,8:24])
plot(nmds1)
plot(nmds1, type = "t")
stressplot(nmds1)

coordenadas <- as.data.frame(scores(nmds1)$sites)
coordenadas

#Le añadimos a las coordenadas una columna con los tramos:
coordenadas$spp = amino$spp
coordenadas$sexo_flor = amino$sexo_flor
head(coordenadas)
# plot
gr2 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
  geom_point(size = 4, aes(colour = spp))+
  theme_bw()+
  scale_color_discrete(name = "Species", 
                       labels =c("CF","CPF","CPP","CAS","CAA","CM") );gr2

#+geom_text(hjust=0.5, vjust=1.5, label=datos$sample)
gr3 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
  geom_point(size = 4, aes(colour = sexo_flor))+
  theme_bw()+
  scale_color_discrete(name = "Floral sex", 
                       labels =c("Female","Male") );gr3
#gr4 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
#  geom_point(size = 4, aes( shape = sexo_flor, colour = spp)); gr4
# haciendo panel de las dos gráficas
library(ggpubr)
# juntado calf1 y calf2
ggarrange(gr2, gr3, 
          labels = c("A", "B"),
          ncol = 1, nrow = 2)
# exportando plot
ggsave("amino_sex4.jpg", device = "jpg", width = 23, height = 23,
       units = "cm", dpi = 300)


# make community matrix - extract columns with abundance information,
# turn data frame into matrix
com = amino[,8:ncol(amino)]
m_com = as.matrix(com)
condicion = c("bosque", "cultivo")

# ANOSIM
ano = anosim(m_com, amino$spp, distance = "bray", permutations = 9999)
ano

ano1 = anosim(m_com, amino$sexo_flor, distance = "bray", permutations = 9999)
ano1

####### GLM de cada aminoacido por separado #####
str(amino)
# concentración de aminoacidos en flores hembra
amino_hem = subset(amino, sexo_flor == "H")
str(amino_hem)
# analisis multivariado de normalidad
mvn(amino_hem[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")

# concentración de aminoacidos en flores hembra
amino_mac = subset(amino, sexo_flor == "M")
str(amino_mac)
# analisis multivariado de normalidad
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")



#### Pollen traits of Cucurbita species ####
#### pollen production ####
contador = read.csv("produccion_polen.csv", header = T)
head(contador)
str(contador)

# Clustering by plant ID
conta = contador %>%
  group_by(año, condicion, spp, id_planta) %>%
  dplyr::summarize(total_mean = mean(polen_total), 
                   es_total = es(polen_total),
                   n = n())
conta
# Descriptive statistics of pollen production.
tapply(conta$total_mean, conta$spp, mean)
tapply(conta$total_mean, conta$spp, es)
tapply(conta$total_mean, conta$spp, length)


# boxplot by species
boxplot(conta$total_mean ~ conta$spp)

# GLM model of pollen production by species
pro2 = glm(total_mean ~ spp, data = conta,
           family = gaussian(link = "identity"))
summary(pro2)
Anova(pro2)
shapiro.test(residuals(pro2))

# Estimated marginal means 
conta_compa <- emmeans(pro2, 
                       specs = pairwise ~ spp, 
                       type = "response")
conta_compa
conta_compa.m<-conta_compa$emmean 
conta_compa.m
model_means_cld_conta <- cld(object = conta_compa.m,
                             adjust = "sidak",
                             Letter = letters, 
                             alpha = 0.05)
model_means_cld_conta

#### Pollen size ####
conta3 = read.csv("pollen_size.csv", header = T)
head(conta3)
str(conta3)

# Descriptive statistics of pollen size.
tapply(conta3$tam, conta3$spp, mean)
tapply(conta3$tam, conta3$spp, es)
tapply(conta3$tam, conta3$spp, length)

# Boxplot of pollen size
boxplot(conta3$tam ~ conta3$spp)

# kruskal-wallis test of pollen size
kruskal.test(tam ~ spp, data = conta3)

# multiple comparisons
pairwise.wilcox.test(conta3$tam, conta3$spp,
                     p.adjust.method = "holm")


#### Protein concentration of pollen ####
proteinas = read.csv("concen_protein.csv", header = T)
head(proteinas)
str(proteinas)
tapply(proteinas$prot, proteinas$Especie, length)
#proteinas$anoplant  <- paste(proteinas$año, proteinas$PlantID)

# Agrupando por individuos
conce_prot = proteinas %>%
  group_by(año, Especie, PlantID, Estatus) %>%
  dplyr::summarize(total_conc = mean(prot), es_total = es(prot), n = n())

# Descriptive statistics of pollen protein concentration
tapply(conce_prot$total_conc, conce_prot$Especie, mean)
tapply(conce_prot$total_conc, conce_prot$Especie, es)
tapply(conce_prot$total_conc, conce_prot$Especie, length)


# GLM of pollen protein concentration
modpro = glm(total_conc ~ Especie, data = conce_prot, family = gaussian)
summary(modpro)
Anova(modpro)
shapiro.test(residuals(modpro))


#### Pollen lipid concentration ####
lipi = read.csv("lipidos.csv", header = T)
head(lipi)
str(lipi)

# Agrupando por individuos
#lipi$anoplant = paste(lipi$año, lipi$PlantID)

# Clustering by species
conce_lipi = lipi %>%
  group_by(año, Especie, PlantID, Estatus) %>%
  dplyr::summarize(total_conc = mean(lipidos), es_total = es(lipidos), n = n())
conce_lipi
#write.csv(conce_lipi, file = "conce_lipi.csv")

# Descriptive statistics of pollen lipid concentration
tapply(conce_lipi$total_conc, conce_lipi$Especie, mean)
tapply(conce_lipi$total_conc, conce_lipi$Especie, es)
tapply(conce_lipi$total_conc, conce_lipi$Especie, length)


boxplot(conce_lipi$total_conc ~ conce_lipi$Especie)
shapiro.test(conce_lipi$total_conc)
hist(conce_lipi$total_conc)

# modelo
m1 = glm(total_conc ~ Especie, data = conce_lipi, family = gaussian)
summary(m1)
Anova(m1)
shapiro.test(residuals(m1))
# Estimated marginal means 
lip_compa <- emmeans(m1, 
                     specs = pairwise ~ Especie, 
                     type = "response")
lip_compa
lip_compa.m<-lip_compa$emmean 
lip_compa.m
model_means_cld_lip <- cld(object = lip_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_lip


#### Protein:Lipid ratio (P:L) ####
pl = read.csv("PL.csv", header = T)  
head(pl)  
str(pl)

# Clustering by individual
pl_res = pl %>%
  group_by(año, Especie, PlantID, Estatus) %>%
  dplyr::summarize(total_pl = mean(pl), es_pl = es(pl), n = n())
pl_res

# Descriptive statistics of protein:lipid ratio
tapply(pl_res$total_pl, pl_res$Especie, mean)
tapply(pl_res$total_pl, pl_res$Especie, es)
tapply(pl_res$total_pl, pl_res$Especie, length)
#write.csv(pl_res, file = "pl.csv")


# Boxplot of protein:lipid ratio
boxplot(pl_res$total_pl ~ pl_res$Especie)
#boxplot(pl_res$total_pl ~ pl_res$Estatus)
shapiro.test(pl_res$total_pl)
hist(pl_res$total_pl)
# GLM
modpl = glm(total_pl ~ Especie, data = pl_res, family = gaussian)
summary(modpl)
Anova(modpl)


#### CALCULANDO SEÑAL FILOGENÉTICA ####
# Cargando base de datos de todos los caracteres de flores hembra (promedios)
traits_hem = read.csv("hembras_mean.csv", header = T, row.names = 1) #, 
head(traits_hem)
str(traits_hem)
traits_hem[2:35]

#### Calculando la señal filogenetica con la función multiPhylosignal del
# paquete "picante"
library(picante)
head(traits_hem)
arbol <- read.nexus("tree7.nex")
class(arbol)
arbol
names(arbol)
arbol$tip.label

# calculando la K de Blomberg. Este valor mide la señal filogenetica o la 
# tendencia de especies relacioanadas a parecerse unas con otras
traits_h <- (traits_hem[2:35])
str(traits_h)
multiPhylosignal(traits_h, arbol)
#multiPhylosignal(traits_h, multi2di(arbol))
# Guardando tabla
write.csv(multiPhylosignal(traits_h, arbol),
          file = "K_blombergs.csv")

#### Calculando señal filogenética con la lambda de Pagel con el ####
# paquete "phytools"
# Load necessary libraries
library(phytools)
library(dplyr)
library(future.apply)  # For cross-platform parallelization

# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores hembra
traits_hem = read.csv("hembras_mean.csv", header = T)
str(traits_hem)
traits_h <- (traits_hem[3:36])
str(traits_h)

# Function to calculate Pagel's lambda and p-value for each trait
calculate_lambda <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_hem$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  lambda_result <- phylosig(tree, trait_vector, method = "lambda", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(lambda = lambda_result$lambda, p_value = lambda_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results <- future_sapply(traits_hem[, 3:36], calculate_lambda, tree = arbol)


# Convert the result to a data frame
trait_results_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_df$trait <- colnames(traits_hem)[3:36]  # Add trait names as a column

# View the result
print(trait_results_df)

# Optionally, save the results to a file
write.csv(trait_results_df, "trait_pagels_lambda_results_hembras.csv",
          row.names = FALSE)

# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores macho
traits_mac = read.csv("machos_mean.csv", header = T)
str(traits_mac)

traits_m <- (traits_mac[3:39])
str(traits_m)

# Function to calculate Pagel's lambda and p-value for each trait
calculate_lambda <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_mac$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  lambda_result <- phylosig(tree, trait_vector, method = "lambda", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(lambda = lambda_result$lambda, p_value = lambda_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results <- future_sapply(traits_mac[, 3:39], calculate_lambda, tree = arbol)


# Convert the result to a data frame
trait_results_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_df$trait <- colnames(traits_mac)[3:39]  # Add trait names as a column

# View the result
print(trait_results_df)

# Optionally, save the results to a file
write.csv(trait_results_df, "trait_pagels_lambda_results_machos.csv",
          row.names = FALSE)






#### Calculando señal filogenética con la K de Blomberg con el paquete ####
# "phytools"
# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores hembra
traits_hem = read.csv("hembras_mean.csv", header = T)
str(traits_hem)
traits_h <- (traits_hem[3:36])
str(traits_h)

# Function to calculate Blomberg's K and p-value for each trait
calculate_ka <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_hem$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  ka_result <- phylosig(tree, trait_vector, method = "K", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(ka = ka_result$K, p_value = ka_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results_ka <- future_sapply(traits_hem[, 3:36], calculate_ka, tree = arbol)


# Convert the result to a data frame
trait_results_ka_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_ka_df$trait <- colnames(traits_hem)[3:36]  # Add trait names as a column

# View the result
print(trait_results_ka_df)

# K de Blomberg
write.csv(trait_results_ka_df, "trait_blomberg_K_results_hembras.csv",
          row.names = FALSE)


# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores MACHO para calcular la K de Blomberg
traits_mac = read.csv("machos_mean.csv", header = T)
str(traits_mac)

traits_m <- (traits_mac[3:39])
str(traits_m)

# Function to calculate Blomberg's K and p-value for each trait
calculate_ka <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_mac$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  ka_result <- phylosig(tree, trait_vector, method = "K", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(ka = ka_result$K, p_value = ka_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results_ka <- future_sapply(traits_mac[, 3:39], calculate_ka, tree = arbol)


# Convert the result to a data frame
trait_results_ka_df <- as.data.frame(t(trait_results_ka))  # Transpose to get traits in rows
trait_results_ka_df$trait <- colnames(traits_mac)[3:39]  # Add trait names as a column

# View the result
print(trait_results_ka_df)

# K de Blomberg
write.csv(trait_results_ka_df, "trait_blomberg_K_results_machos.csv",
          row.names = FALSE)




#### Calculando señal filogenetica por separado para cada rasgo ####
# cargando base de datos
traits_hem = read.csv("hembras_mean.csv", header = T, row.names = 1) #, 
head(traits_hem)
str(traits_hem)
arbol$tip.label # cas, cm, caa, cpf, cpp, cf
# Poniendo el nombre de cada especie
homeRange <- setNames(traits_hem$TL,
                      rownames(traits_hem))
# Calculando señal filogenétiNDf# Calculando señal filogenética
#hrangeLambda = 
kresult = phylosig(arbol, homeRange, method = "K", test = TRUE)
kresult$K
kresult$P

hrangeLambda

# Renombrando 
arbol$tip.label

relabel.tips <- c("Cucurbita argyrosperma subsp. sororia",
                  "Cucurbita moschata*",
                  "Cucurbita argyrosperma subsp. argyrosperma*",
                  "Cucurbita pepo subsp. fraterna",
                  "Cucurbita pepo subsp. pepo*",
                  "Cucurbita foetidissima")
# renombrar terminales
#arbol$tip.label <- mixedFontLabel(relabel.tips, italic = 1)
arbol$tip.label <- relabel.tips
plotTree(arbol)

library(ape)
genus <- c("Cucurbita", "Cucurbita", "Cucurbita", "Cucurbita", "Cucurbita",
           "Cucurbita")
species <- c("argyrosperma subsp. sororia", "moschata*", 
             "argyrosperma subsp. argyrosperma*", "pepo subsp. fraterna",
             "pepo subsp. pepo*", "foetidissima")

arbol$tip.label <- mixedFontLabel(genus, species, italic = 1:2)
plot(arbol)



layout(matrix(c(1, 2), 2))
plot(tr)


plot(c(0, 2), c(0, 2))
text(1, 1, bquote(
  paste(
    italic("Italic Text:"),
    " Some words with new lines. ",
    italic("More italic text:"),
    "Yet more words divided by new lines. ",
    italic("Italics again:"),
    "And more text with new lines.",
    sep = ""
  )
)
)