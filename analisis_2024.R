# In this script I show descriptive statistics and data analysis of floral 
# traits from Cucurbita species evaluated in this study. I also analyze flora
# rewards traits: nectar and pollen traits

#### Functions I use in the analysis ####
# function to obtain standard error
es <- function(x){
  sd(x) / sqrt(length(x))
}
# function to obtain coefficient of variance
cv <- function(x){
  (sd(x)/mean(x))*100
}

#### Package to use ####
library(car)
library(MASS)
library(lme4)
#library(nlme)
#library(fitdistrplus)
library(ggplot2)
library(ggsignif)
library(forcats)
library(dplyr)
library(emmeans)
library(multcomp)
#install.packages("multcompView")
library(multcompView)
library(tidyr)

#### Set up directory in which the databases are located ####
setwd("/home/luis/Documents/3_Doctorado_UNAM/manuscrito_1/data_variables")
#### Loading database of floral traits of pistillate flowers ####
pistillate <- read.csv("traits_pistillate.csv", header = T)
head(pistillate)
str(pistillate)
tapply(pistillate$CD, pistillate$species, length)


# clustering by plant ID
hem_resu <- pistillate %>%
  group_by(year,condition,species,id_plant) %>%
  dplyr::summarize(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
                   TD2 = mean(TD2), TD3 = mean(TD3), NDf = mean(NDf), SD = mean(SD),
                   PL = mean(PL), SL = mean(SL), OL = mean(OL), OD = mean(OD), 
                   n = n())
View(hem_resu)
# as data frame
hem_resu2 <- as.data.frame(hem_resu)
str(hem_resu2)
tapply(hem_resu2$CD, hem_resu2$species, length)

#### Descriptive statistics of pistillate floral traits ####
# Mean by species
media = hem_resu2 %>%
  group_by(species) %>%
  dplyr::summarize(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
                   TD2 = mean(TD2), TD3 = mean(TD3), NDf = mean(NDf), SD = mean(SD),
                   PL = mean(PL), SL = mean(SL), OL = mean(OL), OD = mean(OD), 
                   n = n())
View(media)
# Standard error by species
erro = hem_resu2 %>%
  group_by(species) %>%
  dplyr::summarize(CD = es(CD), TL = es(TL), CL = es(CL), TD1 = es(TD1), 
                   TD2 = es(TD2), TD3 = es(TD3), NDf = es(NDf), SD = es(SD), 
                   PL = es(PL), SL = es(SL), OL = es(OL), OD = es(OD), 
                   n = n())
View(erro)
# Standard deviation
stan_dev = hem_resu2 %>%
  group_by(species) %>%
  dplyr::summarize(CD = sd(CD), TL = sd(TL), CL = sd(CL), TD1 = sd(TD1), 
                   TD2 = sd(TD2), TD3 = sd(TD3), NDf = sd(NDf), SD = sd(SD), 
                   PL = sd(PL), SL = sd(SL), OL = sd(OL), OD = sd(OD), 
                   n = n())
View(stan_dev)
write.csv(stan_dev, file = "desviaciones_flor-hembra.csv")

# Coefficient of variation by species
CV = hem_resu2 %>%
  group_by(species) %>%
  dplyr::summarize(CD = cv(CD), TL = cv(TL), CL = cv(CL), TD1 = cv(TD1),
                   TD2 = cv(TD2), TD3 = cv(TD3), NDf = cv(NDf), SD = cv(SD), 
                   PL = cv(PL), SL = cv(SL), OL = cv(OL), OD = cv(OD),
                   n = n())
View(CV)

#### Principal component analysis (PCA) of pistillate's floral traits ####
# First 6 lines of the database
head(hem_resu2)
str(hem_resu2)
# plotting variables with pairs
pairs(hem_resu2[5:16])
# Performing the PCA with the "prcomp" function
pca1 <- prcomp(hem_resu2[, 5:16], scale = T)
# information generated by the PCA
summary(pca1)
pca1$rotation[, 1:2]
plot(pca1)
# visualization of PCA
biplot(pca1, scale=0)

# Loading libraries to plot PCAs
library(FactoMineR)
library(factoextra)

# Obtaining information on the eigenvalues of the PCA
get_eigenvalue(pca1)
# percentage of variance explained by each component of the PCA
fviz_eig(pca1, addlabels = T)
# Information obtained from the variables we use for the PCA
var = get_pca_var(pca1); var

# Visualizing variables from PCA
fviz_pca_var(pca1, col.var = "black")
# Quality of the representation of the variables in the factor map
head(var$cos2)

# Loading package "corrplot" to visualize correlations
library(corrplot)
# Correlations between variables (cos2)
corrplot(var$cos2, is.corr = F)
# Visualizing the quality of the representation, which variables are best 
# represented.
fviz_cos2(pca1, choice = "var", axes = 1:2)
fviz_pca_var(pca1, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribution of each variable
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca1, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca1, choice = "var", axes = 2, top = 10)
# Contribution of the variables adding the 2 components
fviz_contrib(pca1, choice = "var", axes = 1:2, top = 10)
# PCA plot of the variables colored by contribution 
fviz_pca_var(pca1, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)


### Graph of individuals (rows)
ind = get_pca_ind(pca1)
# Elements that can be taken out of the ind
ind
# Visualizing the individuals in the PCA plot
fviz_pca_ind(pca1)
# Visualizing the individuals in the PCA as a function of cos2
fviz_pca_ind(pca1, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Visualizing the individuals in the PCA as a function of cos2
fviz_pca_ind(pca1, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Total contribution on PC1 and PC2
fviz_contrib(pca1, choice = "ind", axes = 1:2)


# Clustering by species
hem_resu3 <- hem_resu2 %>%
  mutate(species = fct_relevel(species,
                                "CF","CPF", "CAS", "CPP", "CAA", "CM"))
# PCA plot 
pca_hembras <- fviz_pca_ind(pca1,
             #geom.ind = "point", # show points only (nbut not "text")
             habillage = hem_resu3$species, # color by groups
            palette = "Dark2",
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
            #ellipse.level = 0.95,
            legend.title = "Species",
            title = "",
            pointshape = 19,
            pointsize = 1.5,
            label = "none"
)+
  labs(x = "PC 1 (67.8%)", y = "PC 2 (13.3%)")
  #theme(legend.position = "none")
pca_hembras

### PERMANOVA of pistillate flowers
library(vegan)
head(hem_resu2)
str(hem_resu2)
dune5 = hem_resu2[5:16]
# calculating PERMANOVA by species
set.seed(0)
dune.div6 <- adonis2(dune5 ~ species, data = hem_resu2,
                     permutations = 999, method="euclidean")
dune.div6

# calculating beta dispertion (homogeneidad de varianzas)
bd <- betadisper(dune.dist5, hem_resu2$condición)
anova(bd)
permutest(bd)
plot(bd, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=hem_resu2$especie)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


#### Database of floral traits of staminate flowers of Cucurbita species ####
staminate <- read.csv("traits_staminate.csv", header = T)
head(staminate)
str(staminate)

# Clustering by plant ID
staminate2 = staminate %>%
  group_by(year, condition, species, id_plant) %>%
  summarise(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
            TD2 = mean(TD2), TD3 = mean(TD3), NDm = mean(NDm), AD = mean(AD),
            StL = mean(StL), AL = mean(AL), n = n())
View(staminate2)

# as data.frame
staminate2 <- as.data.frame(staminate2)
str(staminate2)
tapply(staminate2$CD, staminate2$species, length)

#### Descriptive statistics of staminate flowers ####
# Mean by species
staminate3 = staminate2 %>%
  group_by(species) %>%
  summarise(CD = mean(CD), TL = mean(TL), CL = mean(CL), TD1 = mean(TD1),
            TD2 = mean(TD2), TD3 = mean(TD3), NDm = mean(NDm), AD = mean(AD),
            StL = mean(StL), AL = mean(AL), n = n())
View(staminate3)
# Standard error by species
erro_m = staminate2 %>%
  group_by(especie) %>%
  summarise(CD = es(CD), TL = es(TL), CL = es(CL), TD1 = es(TD1), 
            TD2 = es(TD2), TD3 = es(TD3), NDm = es(NDm), AD = es(AD), 
            StL = es(StL), AL = es(AL), VN = es(VN), n = n())
View(erro_m)
# SD
erro_m = staminate2 %>%
  group_by(species) %>%
  summarise(CD = sd(CD), TL = sd(TL), CL = sd(CL), TD1 = sd(TD1), 
            TD2 = sd(TD2), TD3 = sd(TD3), NDm = sd(NDm), AD = sd(AD), 
            StL = sd(StL), AL = sd(AL), n = n())
View(erro_m)
write.csv(erro_m, file = "desviaciones_flor-macho.csv")

# Coefficient of variance by especies
cv_m = staminate2 %>%
  group_by(especie) %>%
  summarise(CD = cv(CD), TL = cv(TL), CL = cv(CL), TD1 = cv(TD1),
            TD2 = cv(TD2), TD3 = cv(TD3), NDm = cv(NDm), AD = cv(AD), 
            StL = cv(StL), AL = cv(AL), VN = cv(VN), n = n())

#### Principal component analysis (PCA) of staminate floral traits ####
head(staminate2)
staminate2 = as.data.frame(staminate2)
str(staminate2)
pairs(staminate2[5:14])
# pca of staminate floral traits
pca2 <- prcomp(staminate2[, 5:14], scale = T)
summary(pca2)
pca2$rotation[, 1:2]
#write.csv(pca1$rotation[, 1:2], file = "pca_hembras.csv")
plot(pca2)
biplot(pca2, scale=0)

# Obteniendo información sobre los eigenvalues del PCA
get_eigenvalue(pca2)
# porcentaje de varianza explicada por cada componente del PCA
fviz_eig(pca2, addlabels = T)
# Información que se obtiene de las variables que usamos para el PCA
var = get_pca_var(pca2); var

# Visualizando las variables del PCA
fviz_pca_var(pca2, col.var = "black")
# Calidad de la representación de las variables en el mapa de factores
head(var$cos2)
# Correlaciones entre calidades (cos2)
corrplot(var$cos2, is.corr = F)
# Visualizando la calidad de la representación, que variables estan mejor
# representadas. Grafica de barras y mapa de factores
fviz_cos2(pca2, choice = "var", axes = 1:2)
fviz_pca_var(pca2, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución de cada variable
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca2, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca2, choice = "var", axes = 2, top = 10)
# Contribución de las variables sumando los 2 componentes
fviz_contrib(pca2, choice = "var", axes = 1:2, top = 10)
# Gráfica de PCA de las variables coloreando por contribución 
fviz_pca_var(pca2, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

### Gráfica de individuos (filas)
ind = get_pca_ind(pca2)
# Elementos que se pueden sacar de los ind
ind
# Visualizando los individuos en el grafico de PCA
fviz_pca_ind(pca2)
# Visualizando los individuos en el PCA en función de cos2
fviz_pca_ind(pca2, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Visualizando los individuos en el PCA en funcións de cos2
fviz_pca_ind(pca2, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)
# Total contribution on PC1 and PC2
fviz_contrib(pca2, choice = "ind", axes = 1:2)


# rearrange species name
staminate3 <- staminate2 %>%
  mutate(species = fct_relevel(species,
                    "CF","CPF", "CAS", "CPP", "CAA", "CM"))
pca_machos <- 
  fviz_pca_ind(pca2,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = staminate3$species, # color by groups
             palette = "Dark2",
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
             legend.title = "Species",
             title = "",
             pointshape = 19,
             pointsize = 1.5,
             #label = "none"
)+
  labs(x = "PC 1 (53.2%)", y = "PC 2 (21.9%)")
 #theme(legend.position = "none")

pca_hembras
pca_machos

# code to paste graphs
# loading packages
library(gridExtra)
library(cowplot)
library(ggpubr)
# joining plots
gt <- ggarrange(pca_hembras, pca_machos,
                ncol = 1, nrow = 2, common.legend = TRUE, legend = "right",
                labels="AUTO")
gt
# Exporting plot
ggsave("Figure_1.png", device = "png", width = 172, height = 172,
       units = "mm", dpi = 600, bg = "white")


### PERMANOVA of staminate flowers
head(staminate2)
str(staminate2)
dune6 = staminate2[5:14]
# Calculando distancia euclidiana
set.seed(0)
# calculando PERMANOVA por especie
dune.div7 <- adonis2(dune6 ~ species, data = staminate2,
                     permutations = 999, method="euclidean")
dune.div7

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


#### NECTAR VOLUME ####
# Loading nectar volume combined database
volume = read.csv("nectar_volume.csv", header = T)
head(volume)
str(volume)
# Descriptive statistics
tapply(volume$VN, list(volume$species, volume$sex), mean)
tapply(volume$VN, list(volume$species, volume$sex), sd)
tapply(volume$VN, list(volume$species, volume$sex), es)
tapply(volume$VN, list(volume$species, volume$sex), length)


# GLM of nectar volume by species and floral sex
volu = glm(log(VN) ~ species*sex, data = volume, family = gaussian)
summary(volu) #, dispersion=1
Anova(volu)
shapiro.test(residuals(volu))
plot(residuals(volu))
volu_compa <- emmeans(volu, 
                      specs = pairwise ~ species | sex, 
                      type = "response")
volu_compa
volu_compa.m<-volu_compa$emmean 
volu_compa.m
model_means_cld_volu <- cld(object = volu_compa.m,
                            adjust = "sidak",
                            Letter = letters, 
                            alpha = 0.05)
model_means_cld_volu


# GLM with Gamma distribution
volu2 = glm(VN ~ especie*sexo, data = volumen, family = Gamma)
summary(volu2) #, dispersion=1
Anova(volu2)
shapiro.test(residuals(volu2))
plot(residuals(volu2))

# Plot of nectar volume by species and floral sex
volume2 <- volume %>%
  mutate(species = fct_relevel(species,
                                "1CF","2CPF", "4CAS", "3CPP", "5CAA", "6CM"))
# ggplot
ggplot(volume2, aes(x = species, y = VN, fill = species))+
  geom_boxplot(alpha = 0.5)+
  #geom_point(size = 2, alpha = 0.3, 
  #           position = position_jitter(seed = 1, width = .1))+
  facet_wrap(~sex, scales = "free")+
  labs(x="Species", y = "Nectar volume (μl)")+
  scale_x_discrete(labels=c("1CF" = "CF", "2CPF" = "CPF",
                            "4CAS" = "CAS", "3CPP" = "CPP", "5CAA" = "CAA",
                            "6CM" = "CM"))+
  theme_classic()+
  #theme(panel.grid.major = element_blank(), 
   #     panel.background = element_blank())+
  theme(axis.text = element_text(face = "bold"))+
  theme(legend.position = "none")+
  scale_fill_brewer(palette = "Dark2")


# Plot of nectar volume of pistillate flowers
nec_pis = subset(volume2, sex == "Pistillate")
str(nec_pis)
# ggplot
pisti = ggplot(nec_pis, aes(x = species, y = VN, fill = species))+
  geom_boxplot(alpha = 0.5)+
  #geom_point(size = 2, alpha = 0.3, 
  #           position = position_jitter(seed = 1, width = .1))+
  labs(x="Species", y = "Nectar volume (μl)")+
  scale_x_discrete(labels=c("1CF" = "CF", "2CPF" = "CPF",
                            "4CAS" = "CAS", "3CPP" = "CPP", "5CAA" = "CAA",
                            "6CM" = "CM"))+
  theme_classic()+
  #theme(panel.grid.major = element_blank(), 
  #     panel.background = element_blank())+
  theme(axis.text = element_text(face = "bold"))+
  theme(legend.position = "none")+
  scale_fill_brewer(palette = "Dark2")+
  annotate("text", x=1, y=33, label= "ab", size = 4)+
  annotate("text", x=2, y=50, label= "ab", size = 4)+
  annotate("text", x=3, y=85, label= "a", size = 4)+
  annotate("text", x=4, y=205, label= "c", size = 4)+
  annotate("text", x=5, y=177, label= "bc", size = 4)+
  annotate("text", x=6, y=165, label= "bc", size = 4)

# Plot of nectar volume of staminate flowers
nec_sta = subset(volume2, sex == "Staminate")
str(nec_sta)
# ggplot
stami = ggplot(nec_sta, aes(x = species, y = VN, fill = species))+
  geom_boxplot(alpha = 0.5)+
  #geom_point(size = 2, alpha = 0.3, 
  #           position = position_jitter(seed = 1, width = .1))+
  labs(x="Species", y = "Nectar volume (μl)")+
  scale_x_discrete(labels=c("1CF" = "CF", "2CPF" = "CPF",
                            "4CAS" = "CAS", "3CPP" = "CPP", "5CAA" = "CAA",
                            "6CM" = "CM"))+
  theme_classic()+
  #theme(panel.grid.major = element_blank(), 
  #     panel.background = element_blank())+
  theme(axis.text = element_text(face = "bold"))+
  theme(legend.position = "none")+
  scale_fill_brewer(palette = "Dark2")+
  annotate("text", x=1, y=18, label= "a", size = 4)+
  annotate("text", x=2, y=22, label= "a", size = 4)+
  annotate("text", x=3, y=62, label= "ab", size = 4)+
  annotate("text", x=4, y=88, label= "b", size = 4)+
  annotate("text", x=5, y=71, label= "b", size = 4)+
  annotate("text", x=6, y=63, label= "ab", size = 4)

# code to paste graphs
# loading packages
library(gridExtra)
library(cowplot)
library(ggpubr)
# joining plots
gt <- ggarrange(pisti, stami,
                ncol = 2, nrow = 1, common.legend = FALSE, legend = NULL,
                labels="AUTO")
gt
# Exporting plot
ggsave("Figure_2.png", device = "png", width = 177, height = 108,
       units = "mm", dpi = 600, bg = "white")


#### Nectar sugar concentrations ####
sugars = read.csv("sugar_concentrations.csv", header = T)
head(sugars)
str(sugars)


# Deleting 2 values of CF species of staminate flowers
sugars2 = subset(sugars, spp != "1CF")
str(sugars2)
tapply(sugars2$total_con, list(sugars2$spp, sugars2$sex), length)

# Descriptive statistics of total sugar concentration
tapply(sugars2$total_con, list(sugars2$spp,
                                       sugars2$sex), mean)
tapply(sugars2$total_con, list(sugars2$spp,
                                       sugars2$sex), sd)

# Descriptive statistics of fructose concentration
tapply(sugars2$fructose, list(sugars2$spp,
                                     sugars2$sex), mean)
tapply(sugars2$fructose, list(sugars2$spp,
                                     sugars2$sex), sd)

# Descriptive statistics of glucose concentration
tapply(sugars2$glucose, list(sugars2$spp,
                                    sugars2$sex), mean)
tapply(sugars2$glucose, list(sugars2$spp,
                                    sugars2$sex), sd)

# Descriptive statistics of sucrose concentration
tapply(sugars2$sucrose, list(sugars2$spp,
                                     sugars2$sex), mean)
tapply(sugars2$sucrose, list(sugars2$spp,
                                    sugars2$sex), sd)

# Separando flores hembra
# histogramas de cada azucar
hist(sugars2$fructose)
hist(sugars2$glucose)
hist(sugars2$sucrose)
hist(sugars2$total_con)
# prueba de normalidad
shapiro.test(sugars2$fructose) # no normal
shapiro.test(sugars2$glucose) # no normal
shapiro.test(sugars2$sucrose)
shapiro.test(sugars2$total_con)
# modelado de distribucion
boxplot(sugars2$fructose ~ sugars2$spp)#sugars2$sexo + 
boxplot(sugars2$glucose ~ sugars2$spp)
boxplot(sugars2$sucrose ~ sugars2$spp)
boxplot(sugars2$total_con ~ sugars2$spp)

# glm of fructose
hem_fruc = glm(fructose ~ spp*sex, data = sugars2, family = Gamma)
summary(hem_fruc)
Anova(hem_fruc)
shapiro.test(residuals(hem_fruc))
# comparaciones multiples
fru_compa <- emmeans(hem_fruc, 
                     specs = pairwise ~ spp | sex, 
                     type = "response")
fru_compa
fru_compa.m<-fru_compa$emmean 
fru_compa.m
model_means_cld_fru <- cld(object = fru_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_fru

# glm of glucose
hem_glu = glm(glucose ~ spp*sex, data = sugars2, family = Gamma)
summary(hem_glu)
Anova(hem_glu)
shapiro.test(residuals(hem_glu))
# comparaciones multiples
glu_compa <- emmeans(hem_glu, 
                     specs = pairwise ~ spp | sex, 
                     type = "response")
glu_compa
glu_compa.m<-glu_compa$emmean 
glu_compa.m
model_means_cld_glu <- cld(object = glu_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_glu

### glm de SACAROSA
hem_sac = glm(sucrose ~ spp*sex, data = sugars2, family = gaussian)
summary(hem_sac)
Anova(hem_sac)
shapiro.test(residuals(hem_sac))
plot(residuals(hem_sac))
# comparaciones multiples
sac_compa <- emmeans(hem_sac, 
                     specs = pairwise ~ spp | sex, 
                     type = "response")
sac_compa
sac_compa.m<-sac_compa$emmean 
sac_compa.m
model_means_cld_sac <- cld(object = sac_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_sac

### glm de AZUCAR TOTAL
hem_total = glm(total_con ~ spp*sex, data = sugars2, family = gaussian)
summary(hem_total)
Anova(hem_total)
shapiro.test(residuals(hem_total))
plot(residuals(hem_total))
# comparaciones multiples
total_compa <- emmeans(hem_total, 
                       specs = pairwise ~ spp | sex, 
                       type = "response")
total_compa
total_compa.m<-total_compa$emmean 
total_compa.m
model_means_cld_total <- cld(object = total_compa.m,
                             adjust = "tukey",
                             Letter = letters, 
                             alpha = 0.05)
model_means_cld_total



#### AMINO ACIDS OF NECTAR ####
amino = read.csv("amino_acids_concen.csv", header = TRUE)
str(amino)
head(amino)
tapply(amino$Asp, list(amino$spp,amino$sex), length)

# Mean of each amino acids by species
amino2 = amino %>%
  group_by(spp, sex)  %>%
  dplyr::summarize(Asp2 = mean(Asp), Glu2 = mean(Glu), Ser2 = mean(Ser),
                   His2 = mean(His), Gly2 = mean(Gly), Thr2 = mean(Thr),
                   Arg2 = mean(Arg), Ala2 = mean(Ala), Tyr2 = mean(Tyr),
                   Cys2 = mean(Cys), Val2 = mean(Val), Met2 = mean(Met),
                   Phe2 = mean(Phe), Ile2 = mean(Ile), Leu2 = mean(Leu),
                   Lys2 = mean(Lys), Pro2 = mean(Pro), n = n())
amino2

# Standard error of each amino acid by species
amino3 = amino %>%
  group_by(spp, sex)  %>%
  dplyr::summarize(Asp2 = es(Asp), Glu2 = es(Glu), Ser2 = es(Ser),
                   His2 = es(His), Gly2 = es(Gly), Thr2 = es(Thr),
                   Arg2 = es(Arg), Ala2 = es(Ala), Tyr2 = es(Tyr),
                   Cys2 = es(Cys), Val2 = es(Val), Met2 = es(Met),
                   Phe2 = es(Phe), Ile2 = es(Ile), Leu2 = es(Leu),
                   Lys2 = es(Lys), Pro2 = es(Pro), n = n())

amino3

# Filtering values of C. foetidissima because there are only 2 values
#tapply(amino$Asp, list(amino$spp,amino$sex), length)
#amino2 = subset(amino, spp != "1CF")
#str(amino2)


# loading libraries
library(FactoMineR)
library(factoextra)

### PCA of amino acids by species and floral sex
head(amino)
str(amino)
# visualizing all combinations between the variables
pairs(amino[7:23], lower.panel = NULL)
# Calculando el PCA para flores hembra
pca4 = prcomp(amino[7:23], scale = T)
summary(pca4)
# Obteniendo información sobre los eigenvalues
get_eigenvalue(pca4)
# calculando la varianza explicada por cada componente
fviz_eig(pca4, addlabels = T)
# información que podemos obtener de las variables analizadas
var = get_pca_var(pca4); var
# Visualización de las variables
fviz_pca_var(pca4, col.var = "black")

library(corrplot)
# correlaciones entre calidades de variables
corrplot(var$cos2, is.corr = F)
# Calidad de cada variable 
fviz_cos2(pca4, choice = "var", axes = 1:2)
# graficando las variables en el mapa de factores
fviz_pca_var(pca4, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contribución a los componentes
head(var$contrib)
corrplot(var$contrib, is.corr=FALSE)    

# Contributions of variables to PC1
fviz_contrib(pca4, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pca4, choice = "var", axes = 2, top = 10)
# contribución combinada de los componentes 1  y 2
fviz_contrib(pca4, choice = "var", axes = 1:2, top = 10)
# visualizando las variables coloreadas por contribución
fviz_pca_var(pca4, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

# Solo caracteres del nectar
#fviz_pca_var(pca4, col.var = factor(c("nectar","nectar","nectar",
#                                      "nectar","nectar","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid",
#                                      "aminoacid","aminoacid","aminoacid")), 
#             palette = c("#0073C2FF", "#EFC000FF"),
#             legend.title = "Cluster")

### Graph of individuals (rows)
ind = get_pca_ind(pca4)
ind

fviz_pca_ind(pca4)
# Visualizando los individuos por cos2
fviz_pca_ind(pca4, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping (slow if many points)
)
#
fviz_pca_ind(pca4, pointsize = "cos2", 
             pointshape = 21, fill = "#E7B800",
             repel = TRUE # Avoid text overlapping (slow if many points)
)

# Total contribution on PC1 and PC2
fviz_contrib(pca4, choice = "ind", axes = 1:2)

# Agrupado por condición (SIN elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             fill.ind = amino$sex, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             #addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "euclid",
             legend.title = "Floral sex",
             title = "",
             pointshape=21,
             pointsize = 2
)+
  labs(x = "PC 1 (55%)", y = "PC 2 (11%)")

# Agrupado por condición (CON elipse)
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = amino$sex, # color by groups
             palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
             legend.title = "Floral sex",
             title = "",
             pointshape=19,
             pointsize = 1,
             label = "none"
)+
  labs(x = "PC 1 (55%)", y = "PC 2 (11%)")

# Exporting plot
# loading packages
library(gridExtra)
library(cowplot)
library(ggpubr)

# Exporting plot
ggsave("Figure_3.png", device = "png", width = 177, height = 108,
       units = "mm", dpi = 600, bg = "white")




# Agrupado por especie
fviz_pca_ind(pca4,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = amino$spp, # color by groups
             palette = c("#00AFBB", "#E7B800","#FC4E07", "#00AFDB",
                         "#E7B850"), # falta una especie
             addEllipses = TRUE, # Concentration ellipses
             #ellipse.type = "confidence",
             legend.title = "Groups"
)


library(MVN)
# Flores hembra
mvn(nectar_h[8:29], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")
mvn(nectar_h[8:12], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# Flores macho
mvn(nectar_m[8:29], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")


# PERMANOVA dof amino acids by floral sex
library(vegan)
str(amino)
amino[7:23]
dune8 = amino[7:23]
# Calculando distancia euclidiana
set.seed(0)
# permanova
dune.div8 <- adonis2(dune8 ~ spp*sex, by="terms", data = amino,
                     permutations = 999, method="euclidean")
dune.div8


# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse


# cargando paquete factoextra
library(factoextra)
# Top 10 variables que más contribuyen a PC1
fviz_contrib(pca4, choice = "var", axes = 1, top = 10)
fviz_contrib(pca4, choice = "var", axes = 2, top = 10)
# plot
fviz_pca_biplot(pca4, geom.ind = "point",
                axes = c(1,2), pointsize = 2, title = "", geom.var = c("",""),
)

# cargando paquete para graficar PCA
library(ggfortify)
autoplot(pca4)
pca_ami1 = autoplot(pca4, data = amino, colour = "condición", size = 2)+
  xlab("PC 1 (55.7%)") +
  ylab("PC 2 (11%)") +
  scale_color_discrete(name = "Condición",
                       labels = c("Domesticadas", "Silvestres"))+
  theme_bw()
pca_ami1
# aminoacidos por sexo
pca_ami2 = autoplot(pca4, data = amino, colour = "sexo_flor", size = 2)+
  xlab("PC 1 (55.7%)") +
  ylab("PC 2 (11%)")+
  scale_color_discrete(name = "Sexo floral",
                       labels = c("Hembras", "Machos"))+
  theme_bw()
pca_ami2

# Normalidad multivariada
library(MVN)
# test de normalidad
# test de Mardia en MVN
result <- mvn(data = amino[8:24], mvnTest = "mardia")
result$multivariateNormality
# Henze-Zirkler's MVN test
result <- mvn(data = amino[8:24], mvnTest = "hz")
result$multivariateNormality
# Royston's MVN test
result <- mvn(data = amino[8:24], mvnTest = "royston")
result$multivariateNormality
# Doornik-Hansen's MVN test
result <- mvn(data = amino[8:24], mvnTest = "dh")
result$multivariateNormality
# Energy test
result <- mvn(data = amino[8:24], mvnTest = "energy")
result$multivariateNormality


#library(devtools)
#install_github("vqv/ggbiplot")
library(ggbiplot)
ca.condicion3 = amino[,3]
ca.species3 = amino[, 4]
ca.sex3 = amino[,6]

#
ggbiplot(pca3)
# PCA por condición
ggbiplot(pca3, obs.scale = 1, var.scale = 1, 
         groups = ca.condicion3, ellipse = F, 
         circle = F) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', 
        legend.position = 'bottom')
# PCA por especie
ggbiplot(pca3, obs.scale = 1, var.scale = 1, 
         groups = ca.species3, ellipse = F, 
         circle = F) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', 
        legend.position = 'bottom')
# PCA por sexo
ggbiplot(pca3, obs.scale = 1, var.scale = 1, 
         groups = ca.sex3, ellipse = F, 
         circle = F) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', 
        legend.position = 'bottom')

# PCoA con vegan
library(vegan)
cucu_dist = dist(amino[,c(8:24)])
cucu_PCoA <- wcmdscale(d = cucu_dist, eig = TRUE)
cucu_PCoA
cucu_PCoA$points
# gráfica del PCoA
ggplot(data = data.frame(cucu_PCoA$points),
       aes(x = Dim1, y = Dim2)) +
  geom_point() +
  theme_bw()

# PCoA por condición
pcoa <- cmdscale(cucu_dist, eig = TRUE, add = TRUE)
#convert pcoa results into data frame that can be plotted
pcoa_df <- data.frame(pcoa$points)
colnames(pcoa_df) <- c("PCo1", "PCo2")
pcoa_df$condi <- factor(amino$condición) #add group of interest,
# mine was Morphospecies in the data frame cal_fem_data2
calf1 <- ggplot(pcoa_df, aes(x = PCo1, y = PCo2, color = condi)) + 
  geom_point(size = 1) +
  xlab("PCo1") +
  ylab("PCo2") + 
  ggtitle("") +
  theme_classic()+
  scale_color_discrete(name="Condition",
                       labels = c("Domesticated", "Wild"))

calf1
# PCoA agrupado por sexo floral
pcoa1 <- cmdscale(cucu_dist, eig = TRUE, add = TRUE)
#convert pcoa results into data frame that can be plotted
pcoa1_df <- data.frame(pcoa1$points)
colnames(pcoa1_df) <- c("PCo1", "PCo2")
pcoa_df$sexo <- factor(amino$sexo_flor) #add group of interest,
# mine was Morphospecies in the data frame cal_fem_data2
calf2 <- ggplot(pcoa_df, aes(x = PCo1, y = PCo2, color = sexo)) + 
  geom_point(size = 1) +
  xlab("PCo1") +
  ylab("PCo2") + 
  ggtitle("") +
  theme_classic()+
  scale_color_discrete(name = "Floral sex", labels = c("Female", "Male"))
calf2

# haciendo panel de las dos gráficas
library(ggpubr)
# juntado calf1 y calf2
ggarrange(calf1, calf2, 
          labels = c("A", "B"),
          ncol = 1, nrow = 2)
# exportando plot
ggsave("amino_sex.jpg", device = "jpg", width = 11.5, height = 11.5,
       units = "cm", dpi = 300)





### PERMANOVA DE LOS DIFERENTES AMINOACIDOS
library(vegan)
head(amino)
amino$tratamiento
dune5 = amino[8:24]
# Calculando distancia euclidiana
dune.dist5 <- vegdist(dune5, method="euclidean")

# calculando PERMANOVA por condición
dune.div5 <- adonis2(dune5 ~ condición*sexo_flor, data = amino,
                     permutations = 999, method="euclidean")
dune.div5

# calculando PERMANOVA por especie
dune.div6 <- adonis2(dune5 ~ sexo_flor, data = amino,
                     permutations = 999, method="euclidean")
dune.div6

# overall tests
#adonis2(dune ~ especie, data = hembras, 
#        permutations = 999, method="euclidean", by = NULL)

# calculando beta dispersión (homogeneidad de varianzas)
dispersion5 <- betadisper(dune.dist5, group=amino$condición)
permutest(dispersion5)
plot(dispersion5, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por especie
dispersion6 <- betadisper(dune.dist5, group=amino$spp)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse
# calculando dispersión por sexo
dispersion6 <- betadisper(dune.dist5, group=amino$sexo_flor)
permutest(dispersion6)
plot(dispersion6, hull=FALSE, ellipse=T) ##sd ellipse

#### NMDS con los datos de aminoacidos ####
library(vegan)
str(amino)
head(amino)

set.seed(0)#Para que los resultados no se brinden aleatorios
nmds1 <- metaMDS(amino[,8:24])
plot(nmds1)
plot(nmds1, type = "t")
stressplot(nmds1)

coordenadas <- as.data.frame(scores(nmds1)$sites)
coordenadas

#Le añadimos a las coordenadas una columna con los tramos:
coordenadas$spp = amino$spp
coordenadas$sexo_flor = amino$sexo_flor
head(coordenadas)
# plot
gr2 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
  geom_point(size = 4, aes(colour = spp))+
  theme_bw()+
  scale_color_discrete(name = "Species", 
                       labels =c("CF","CPF","CPP","CAS","CAA","CM") );gr2

#+geom_text(hjust=0.5, vjust=1.5, label=datos$sample)
gr3 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
  geom_point(size = 4, aes(colour = sexo_flor))+
  theme_bw()+
  scale_color_discrete(name = "Floral sex", 
                       labels =c("Female","Male") );gr3
#gr4 <- ggplot(coordenadas, aes(x = NMDS1, y = NMDS2))+ 
#  geom_point(size = 4, aes( shape = sexo_flor, colour = spp)); gr4
# haciendo panel de las dos gráficas
library(ggpubr)
# juntado calf1 y calf2
ggarrange(gr2, gr3, 
          labels = c("A", "B"),
          ncol = 1, nrow = 2)
# exportando plot
ggsave("amino_sex4.jpg", device = "jpg", width = 23, height = 23,
       units = "cm", dpi = 300)


# make community matrix - extract columns with abundance information,
# turn data frame into matrix
com = amino[,8:ncol(amino)]
m_com = as.matrix(com)
condicion = c("bosque", "cultivo")

# ANOSIM
ano = anosim(m_com, amino$spp, distance = "bray", permutations = 9999)
ano

ano1 = anosim(m_com, amino$sexo_flor, distance = "bray", permutations = 9999)
ano1

####### GLM de cada aminoacido por separado #####
str(amino)
# concentración de aminoacidos en flores hembra
amino_hem = subset(amino, sexo_flor == "H")
str(amino_hem)
# analisis multivariado de normalidad
mvn(amino_hem[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")

# concentración de aminoacidos en flores hembra
amino_mac = subset(amino, sexo_flor == "M")
str(amino_mac)
# analisis multivariado de normalidad
mvn(amino_mac[8:24], mvnTest = "hz", univariateTest = "SW", 
    univariatePlot = "histogram")



#### Pollen traits of Cucurbita species ####
#### pollen production ####
contador = read.csv("pollen_production.csv", header = T)
head(contador)
str(contador)

# Clustering by plant ID
conta = contador %>%
  group_by(year, condition, spp, id_plant) %>%
  dplyr::summarize(total_mean = mean(pollen_total), 
                   es_total = es(pollen_total),
                   n = n())
conta
# Descriptive statistics of pollen production.
tapply(conta$total_mean, conta$spp, mean)
tapply(conta$total_mean, conta$spp, es)
tapply(conta$total_mean, conta$spp, length)
tapply(conta$total_mean, conta$spp, sd)

# boxplot by species
boxplot(conta$total_mean ~ conta$spp)

# GLM model of pollen production by species
pro2 = glm(total_mean ~ spp, data = conta,
           family = gaussian(link = "identity"))
summary(pro2)
Anova(pro2)
shapiro.test(residuals(pro2))

# Estimated marginal means 
conta_compa <- emmeans(pro2, 
                       specs = pairwise ~ spp, 
                       type = "response")
conta_compa
conta_compa.m<-conta_compa$emmean 
conta_compa.m
model_means_cld_conta <- cld(object = conta_compa.m,
                             adjust = "sidak",
                             Letter = letters, 
                             alpha = 0.05)
model_means_cld_conta

#### Pollen size ####
conta3 = read.csv("pollen_size.csv", header = T)
head(conta3)
str(conta3)

# Descriptive statistics of pollen size.
tapply(conta3$size, conta3$spp, mean)
tapply(conta3$size, conta3$spp, es)
tapply(conta3$size, conta3$spp, length)
tapply(conta3$size, conta3$spp, sd)

# Boxplot of pollen size
boxplot(conta3$size ~ conta3$spp)

# kruskal-wallis test of pollen size
kruskal.test(size ~ spp, data = conta3)

# multiple comparisons
pairwise.wilcox.test(conta3$size, conta3$spp,
                     p.adjust.method = "holm")


#### Protein concentration of pollen ####
protein = read.csv("protein_pollen.csv", header = T)
head(protein)
str(protein)
tapply(protein$protein, protein$species, length)
#proteinas$anoplant  <- paste(proteinas$año, proteinas$PlantID)

# Clustering by individual
conce_prot = protein %>%
  group_by(year, species, plant_id, condition) %>%
  dplyr::summarize(total_conc = mean(protein), es_total = es(protein), n = n())

# Descriptive statistics of pollen protein concentration
tapply(conce_prot$total_conc, conce_prot$species, mean)
tapply(conce_prot$total_conc, conce_prot$species, es)
tapply(conce_prot$total_conc, conce_prot$species, length)
tapply(conce_prot$total_conc, conce_prot$species, sd)

# GLM of pollen protein concentration
modpro = glm(total_conc ~ species, data = conce_prot, family = gaussian)
summary(modpro)
Anova(modpro)
shapiro.test(residuals(modpro))


#### Pollen lipid concentration ####
lipi = read.csv("lipids_pollen.csv", header = T)
head(lipi)
str(lipi)

# Agrupando por individuos
#lipi$anoplant = paste(lipi$año, lipi$PlantID)

# Clustering by species
conce_lipi = lipi %>%
  group_by(year, species, plant_id, condition) %>%
  dplyr::summarize(total_conc = mean(lipids), es_total = es(lipids), n = n())
conce_lipi
#write.csv(conce_lipi, file = "conce_lipi.csv")

# Descriptive statistics of pollen lipid concentration
tapply(conce_lipi$total_conc, conce_lipi$species, mean)
tapply(conce_lipi$total_conc, conce_lipi$species, es)
tapply(conce_lipi$total_conc, conce_lipi$species, length)
tapply(conce_lipi$total_conc, conce_lipi$species, sd)

boxplot(conce_lipi$total_conc ~ conce_lipi$species)
shapiro.test(conce_lipi$total_conc)
hist(conce_lipi$total_conc)

# modelo
m1 = glm(total_conc ~ species, data = conce_lipi, family = gaussian)
summary(m1)
Anova(m1)
shapiro.test(residuals(m1))
# Estimated marginal means 
lip_compa <- emmeans(m1, 
                     specs = pairwise ~ species, 
                     type = "response")
lip_compa
lip_compa.m<-lip_compa$emmean 
lip_compa.m
model_means_cld_lip <- cld(object = lip_compa.m,
                           adjust = "sidak",
                           Letter = letters, 
                           alpha = 0.05)
model_means_cld_lip


#### Protein:Lipid ratio (P:L) ####
pl = read.csv("PL.csv", header = T)  
head(pl)  
str(pl)

# Clustering by individual
pl_res = pl %>%
  group_by(year, species, plant_id, condition) %>%
  dplyr::summarize(total_pl = mean(pl), es_pl = es(pl), n = n())
pl_res

# Descriptive statistics of protein:lipid ratio
tapply(pl_res$total_pl, pl_res$species, mean)
tapply(pl_res$total_pl, pl_res$species, es)
tapply(pl_res$total_pl, pl_res$species, length)
tapply(pl_res$total_pl, pl_res$species, sd)
#write.csv(pl_res, file = "pl.csv")


# Boxplot of protein:lipid ratio
boxplot(pl_res$total_pl ~ pl_res$species)
#boxplot(pl_res$total_pl ~ pl_res$Estatus)
shapiro.test(pl_res$total_pl)
hist(pl_res$total_pl)
# GLM
modpl = glm(total_pl ~ species, data = pl_res, family = gaussian)
summary(modpl)
Anova(modpl)


#### CALCULANDO SEÑAL FILOGENÉTICA ####
# Cargando base de datos de todos los caracteres de flores hembra (promedios)
traits_hem = read.csv("hembras_mean.csv", header = T, row.names = 1) #, 
head(traits_hem)
str(traits_hem)
traits_hem[2:35]

#### Calculando la señal filogenetica con la función multiPhylosignal del
# paquete "picante"
library(picante)
head(traits_hem)
arbol <- read.nexus("tree7.nex")
class(arbol)
arbol
names(arbol)
arbol$tip.label

# calculando la K de Blomberg. Este valor mide la señal filogenetica o la 
# tendencia de especies relacioanadas a parecerse unas con otras
traits_h <- (traits_hem[2:35])
str(traits_h)
multiPhylosignal(traits_h, arbol)
#multiPhylosignal(traits_h, multi2di(arbol))
# Guardando tabla
write.csv(multiPhylosignal(traits_h, arbol),
          file = "K_blombergs.csv")

#### Calculando señal filogenética con la lambda de Pagel con el ####
# paquete "phytools"
# Load necessary libraries
library(phytools)
library(dplyr)
library(future.apply)  # For cross-platform parallelization

# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores hembra
traits_hem = read.csv("hembras_mean.csv", header = T)
str(traits_hem)
traits_h <- (traits_hem[3:36])
str(traits_h)

# Function to calculate Pagel's lambda and p-value for each trait
calculate_lambda <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_hem$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  lambda_result <- phylosig(tree, trait_vector, method = "lambda", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(lambda = lambda_result$lambda, p_value = lambda_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results <- future_sapply(traits_hem[, 3:36], calculate_lambda, tree = arbol)


# Convert the result to a data frame
trait_results_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_df$trait <- colnames(traits_hem)[3:36]  # Add trait names as a column

# View the result
print(trait_results_df)

# Optionally, save the results to a file
write.csv(trait_results_df, "trait_pagels_lambda_results_hembras.csv",
          row.names = FALSE)

# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores macho
traits_mac = read.csv("machos_mean.csv", header = T)
str(traits_mac)

traits_m <- (traits_mac[3:39])
str(traits_m)

# Function to calculate Pagel's lambda and p-value for each trait
calculate_lambda <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_mac$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  lambda_result <- phylosig(tree, trait_vector, method = "lambda", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(lambda = lambda_result$lambda, p_value = lambda_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results <- future_sapply(traits_mac[, 3:39], calculate_lambda, tree = arbol)


# Convert the result to a data frame
trait_results_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_df$trait <- colnames(traits_mac)[3:39]  # Add trait names as a column

# View the result
print(trait_results_df)

# Optionally, save the results to a file
write.csv(trait_results_df, "trait_pagels_lambda_results_machos.csv",
          row.names = FALSE)






#### Calculando señal filogenética con la K de Blomberg con el paquete ####
# "phytools"
# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores hembra
traits_hem = read.csv("hembras_mean.csv", header = T)
str(traits_hem)
traits_h <- (traits_hem[3:36])
str(traits_h)

# Function to calculate Blomberg's K and p-value for each trait
calculate_ka <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_hem$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  ka_result <- phylosig(tree, trait_vector, method = "K", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(ka = ka_result$K, p_value = ka_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results_ka <- future_sapply(traits_hem[, 3:36], calculate_ka, tree = arbol)


# Convert the result to a data frame
trait_results_ka_df <- as.data.frame(t(trait_results))  # Transpose to get traits in rows
trait_results_ka_df$trait <- colnames(traits_hem)[3:36]  # Add trait names as a column

# View the result
print(trait_results_ka_df)

# K de Blomberg
write.csv(trait_results_ka_df, "trait_blomberg_K_results_hembras.csv",
          row.names = FALSE)


# cargando la base de datos que contiene los promedios de todos los caracteres
# medidos en flores MACHO para calcular la K de Blomberg
traits_mac = read.csv("machos_mean.csv", header = T)
str(traits_mac)

traits_m <- (traits_mac[3:39])
str(traits_m)

# Function to calculate Blomberg's K and p-value for each trait
calculate_ka <- function(trait_column, tree) {
  # Combine species and trait column into a temporary data frame
  temp_data <- data.frame(species = traits_mac$especie, trait = trait_column)
  
  # Calculate the mean trait value per species
  #species_means <- temp_data %>%
  # group_by(species) %>%
  #summarise(mean_trait = mean(trait, na.rm = TRUE))
  
  # Create a named vector of trait values for the species
  trait_vector <- temp_data$trait
  names(trait_vector) <- temp_data$species
  
  # Use the phylosig function to calculate Pagel's lambda
  ka_result <- phylosig(tree, trait_vector, method = "K", test = TRUE)
  
  # Return a named vector with lambda and p-value
  return(c(ka = ka_result$K, p_value = ka_result$P))  # Corrected p-value reference
}

# Set up parallelization using future.apply (works across platforms)
#plan(multisession)  # Enables parallel processing

# Apply this function to each trait in columns 3 to 12 using future_sapply for parallel execution
trait_results_ka <- future_sapply(traits_mac[, 3:39], calculate_ka, tree = arbol)


# Convert the result to a data frame
trait_results_ka_df <- as.data.frame(t(trait_results_ka))  # Transpose to get traits in rows
trait_results_ka_df$trait <- colnames(traits_mac)[3:39]  # Add trait names as a column

# View the result
print(trait_results_ka_df)

# K de Blomberg
write.csv(trait_results_ka_df, "trait_blomberg_K_results_machos.csv",
          row.names = FALSE)




#### Calculando señal filogenetica por separado para cada rasgo ####
# cargando base de datos
traits_hem = read.csv("hembras_mean.csv", header = T, row.names = 1) #, 
head(traits_hem)
str(traits_hem)
arbol$tip.label # cas, cm, caa, cpf, cpp, cf
# Poniendo el nombre de cada especie
homeRange <- setNames(traits_hem$TL,
                      rownames(traits_hem))
# Calculando señal filogenétiNDf# Calculando señal filogenética
#hrangeLambda = 
kresult = phylosig(arbol, homeRange, method = "K", test = TRUE)
kresult$K
kresult$P

hrangeLambda

# Renombrando 
arbol$tip.label

relabel.tips <- c("Cucurbita argyrosperma subsp. sororia",
                  "Cucurbita moschata*",
                  "Cucurbita argyrosperma subsp. argyrosperma*",
                  "Cucurbita pepo subsp. fraterna",
                  "Cucurbita pepo subsp. pepo*",
                  "Cucurbita foetidissima")
# renombrar terminales
#arbol$tip.label <- mixedFontLabel(relabel.tips, italic = 1)
arbol$tip.label <- relabel.tips
plotTree(arbol)

library(ape)
genus <- c("Cucurbita", "Cucurbita", "Cucurbita", "Cucurbita", "Cucurbita",
           "Cucurbita")
species <- c("argyrosperma subsp. sororia", "moschata*", 
             "argyrosperma subsp. argyrosperma*", "pepo subsp. fraterna",
             "pepo subsp. pepo*", "foetidissima")

arbol$tip.label <- mixedFontLabel(genus, species, italic = 1:2)
plot(arbol)



layout(matrix(c(1, 2), 2))
plot(tr)


plot(c(0, 2), c(0, 2))
text(1, 1, bquote(
  paste(
    italic("Italic Text:"),
    " Some words with new lines. ",
    italic("More italic text:"),
    "Yet more words divided by new lines. ",
    italic("Italics again:"),
    "And more text with new lines.",
    sep = ""
  )
)
)